#!/bin/sh

#
# BMT - Bhyve Management Tool
#
# Created by Steven Douglas /w improvements by Adam Strohl
#

# Script Version
VERSION="0.1.25"

# What directory do the vms live in?
VM_LIVES="/usr/local/vms"

# Base zpath hack
BASE_ZPATH="zroot/vms"

# Load config file if present
if [ -r "/usr/local/etc/bmt.conf" ]; then
   . /usr/local/etc/bmt.conf;
fi

vml_start () {
      if [ "${ARG_BONUS}" == "-d" ]; then
         BMT_DEBUG="YES"; 
      fi
      # Screen
      if [ "$IN_SCREEN" != "YES" -a -z "${BMT_DEBUG}" ]; then
         if [ -z "${BMT_DEBUG}" ]; then
            `/usr/local/bin/screen -dmS bhyve."$VM_NAME" "$SCRIPT" start $VM_NAME is &`
            exit;
         else
            echo "Debugging mode enabled, not launching in screen";
            `"$SCRIPT" start $VM_NAME is &`;
            exit;
         fi
      fi
      
      # Reboot loop
      while [ 1 ]; do

         # Execute the pre command
         if [ "${VM_PRE_CMD}" != "" ]; then
            `${VM_PRE_CMD}`
         fi

         # Destroy any existing VM's with my name
         bhyvectl --vm=$VM_NAME --destroy 2> /dev/null

         # Figure out the PCI devices
         FINAL_PCI=""
         I=2

         # Networking Devices
         for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
            PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
            BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
            PREFIX_TAP="VM_N${j}_TAP_NUM"
            TAP=`eval echo "\$""$PREFIX_TAP"`
            
            if [ "$TAP" != "" ]; then

               if [ "$AUTO_NETWORKING" == "YES" ]; then
                  ifconfig tap${TAP} create 
#                    TAP=`ifconfig tap create | tr -d "\n"`
                  ifconfig bridge$BRIDGE addm tap$TAP
               fi

               FINAL_PCI=$FINAL_PCI" -s $I,virtio-net,tap$TAP "
               I=$((I+1))
            fi
         done

         # Scrape any zvols from our current dataset as disks
         echo "(hd0) /dev/zvol/$ZPATH/$VM_BOOT_ZVOL" > $SCRIPTPATH/device.map
         if [ "$VM_CDROM" == "1" ] ; then
            echo "(cd0) $VM_CDROM_MEDIA" >> $SCRIPTPATH/device.map
            FINAL_PCI=$FINAL_PCI" -s $I,ahci-cd,$VM_CDROM_MEDIA "
            I=$((I+1))
            BOOT_DEVICE="cd0"
         else
            BOOT_DEVICE="hd0,msdos"$VM_BOOT_PART
         fi
         for ds in `zfs list -r -H -t volume -o name $ZPATH`
         do
           FINAL_PCI=$FINAL_PCI" -s $I,ahci-hd,/dev/zvol/$ds "
           echo "Adding disk (zvol) $ds"
           I=$((I+1))
         done

         # Get pci passthru devices
         for pci_dev in $VM_PCI_PT; do
           FINAL_PCI=$FINAL_PCI" -s $I,passthru,${pci_dev} "
           echo "Adding PCI PT ${pci_dev}"
           I=$((I+1))
         done
         
         # Add file-based disks
         for ds in ${VM_DISK_FILES}
         do
           FINAL_PCI=$FINAL_PCI" -s $I,ahci-hd,$ds "
           echo "Adding disk (file) $ds"
           I=$((I+1))
         done
         
         # Add Framebuffer
         if [ "$VM_FRAMEBUFFER" == "1" ] ; then
            FINAL_PCI=$FINAL_PCI" -s $I,fbuf,$VM_FRAMEBUFFER_OPTS "
            I=$((I+1))
         fi
         
         # Add USB 3.0
         if [ "$VM_USB3" == "1" ] ; then
            FINAL_PCI=$FINAL_PCI" -s $I,xhci,tablet "
            I=$((I+1))
         fi

         # Make sure that FreeBSD can see the boot vol's partitions
         gpart list zvol/${ZPATH}/${VM_BOOT_ZVOL} >> /tmp/caker

         # FreeBSD
         if [ "$VM_QUIRK" == "0" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               bhyveload -d $VM_CDROM_MEDIA -m $VM_MEMORY"M" $VM_NAME
            else
               bhyveload -d "/dev/zvol/$ZPATH/$VM_BOOT_ZVOL" -m $VM_MEMORY"M" $VM_NAME
            fi
         # Quirk CentOS 6.x
         elif [ "$VM_QUIRK" == "1" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/isolinux/vmlinuz" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/isolinux/initrd.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               # Generate grub.cfg
               MOUNTPOINT="/tmp/$VM_NAME"
               if ! mkdir $MOUNTPOINT; then
                  fatal_error "Couldn't create temporary mountpoint for grub.cfg generation (${MOUNTPOINT})";
               fi
               
               if ! ext4fuse /dev/zvol/$ZPATH/$VM_BOOT_ZVOL"s"$VM_BOOT_PART $MOUNTPOINT; then
                  rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't mount boot partition with fuse";
               fi
               
               if ! VMLINUZ_PATH=`find "$MOUNTPOINT/boot/" \( ! -name '.*' \) -type f -name "vmlinuz*" | sed -e "s,$MOUNTPOINT,,g" | sort | tail -n 1`; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't run find operation for vmlinuz file";
               fi
               
               if [ -z "${VMLINUZ_PATH}" ]; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't find vmlinuz file in guest disk /boot";
               fi
               
               if ! INITRAMFS_PATH=`find "$MOUNTPOINT/boot/" \( ! -name '.*' \) -type f -name "initramfs*" | sed -e "s,$MOUNTPOINT,,g " | sort | tail -n 1`; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't run find operation for initramfs file";
               fi

               if [ -z "${INITRAMFS_PATH}" ]; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't find initramfs file in guest disk /boot";
               fi
               
               umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";

               rm $SCRIPTPATH/grub.cfg
               echo "set root=($BOOT_DEVICE)" >> $SCRIPTPATH/grub.cfg
               echo "linux (hd0,msdos$VM_BOOT_PART)$VMLINUZ_PATH root=/dev/sda""$VM_BOOT_PART" >> $SCRIPTPATH/grub.cfg
               echo "initrd (hd0,msdos$VM_BOOT_PART)$INITRAMFS_PATH" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg


               # Run Grub
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi
         # Quirk CentOS 7.x
         elif [ "$VM_QUIRK" == "2" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/isolinux/vmlinuz" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/isolinux/initrd.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               if [ -z "${VM_GRUB_DIR}" ]; then
                  VM_GRUB_DIR="/boot/grub2";
               fi
               /usr/local/sbin/grub-bhyve -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk Ubuntu
         elif [ "$VM_QUIRK" == "3" ]; then
            if [ -z "${VM_GRUB_DIR}" ]; then
               VM_GRUB_DIR="/boot/grub";
            fi
            /usr/local/sbin/grub-bhyve -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

         # Quirk Fedora 
         elif [ "$VM_QUIRK" == "4" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               /usr/local/sbin/grub-bhyve -d /isolinux/ -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            else
               if [ -z "${VM_GRUB_DIR}" ]; then
                  VM_GRUB_DIR="/grub2";
               fi
               /usr/local/sbin/grub-bhyve -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk arch         
         elif [ "$VM_QUIRK" == "5" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_201601" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/arch/boot/x86_64/archiso.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk NetBSD 
         elif [ "$VM_QUIRK" == "6" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
#              echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "knetbsd -h -r cd0a (cd0)/netbsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               rm $SCRIPTPATH/grub.cfg
               echo "knetbsd -h -r wd0a (${BOOT_DEVICE})/netbsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk OpenBSD
         elif [ "$VM_QUIRK" == "7" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               rm $SCRIPTPATH/grub.cfg
               echo "kopenbsd -h com0 -r sd0a (hd0,openbsd${BOOT_PART})/bsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk Windows10
         elif [ "$VM_QUIRK" == "8" ]; then
            #echo "Windows 10 ... nothing to do :P"
            USE_BOOTROM="-l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd";
         else
            echo "VM_QUIRK NOT SET"
         fi

         /usr/sbin/bhyve -c $VM_CPUS -m $VM_MEMORY"M" -A -H -w -s 0,hostbridge -s 31,lpc $FINAL_PCI -l com1,stdio $USE_BOOTROM $VM_NAME
         bhyve_exit=$?

         # Clean up the vm, its time to destroy it.
         bhyvectl --vm=$VM_NAME --destroy 2> /dev/null


         # Only loop if the exit code was 0 (reboot)
         if [ $bhyve_exit -ne 0 ]; then
            echo "VM Shutdown detected, not looping."
            break
         else
            echo "VM Reboot detected, looping"
            # -- Re-read the config file in case it's changed
            . "${VM_ROOT}/vm.conf";
         fi

      done

      # Tidy up any auto networking that was done
      for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
         PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
         BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
         PREFIX_TAP="VM_N${j}_TAP_NUM"
         TAP=`eval echo "\$""$PREFIX_TAP"`
         
         if [ "$TAP" != "" ]; then
            if [ "$AUTO_NETWORKING" == "YES" ]; then
               ifconfig bridge$BRIDGE deletem tap$TAP 2> /dev/null
               ifconfig tap$TAP destroy 2> /dev/null
            fi
         fi
      done
   
   if [ "${VM_POST_CMD}" != "" ]; then
      `${VM_POST_CMD}`
   fi
}

vml_stat() {
#  bhyvectl --vm=$VM_NAME --get-all | wc -l | tr -d " " | tr -d "\n"
   if [ "`bhyvectl --vm=$VM_NAME --get-all | wc -l | tr -d " " | tr -d "\n"`" == "1" ]; then
      return 0
   else
      return 1
   fi
}

vml_attach(){
   vml_stat
   if [ "$?" == "1" ]; then
      screen -r bhyve."$VM_NAME"
   else
      echo "VM is not running"
   fi

}

vml_status(){
   vml_stat
   if [ "$?" == "1" ]; then
      echo "VM is running"
   else
      echo "VM is not running"
   fi

}

fatal_error() {
   MESSAGE="${1}";
   echo " >>> ERROR: ${MESSAGE}";
   echo " >>> Exiting.";
   exit 1;
}

find_all_configs () {
   LIST=`find $VM_LIVES | grep "/vm.conf$" | sort -V -t . -k 2 -k 1`;
   echo "${LIST}";
}

get_config_file_name () {
   VM_NAME="$1";
   
   CONF_FILE="${VM_LIVES}/${VM_NAME}/vm.conf";
   
   if [ -e "${CONF_FILE}" ]; then
      echo "${CONF_FILE}";
   fi
}

find_all_bridges () {
   LIST=`ifconfig -a | grep bridge[0-9+]: | awk -F : '{print $1}'`;
   echo "${LIST}";
}

clear_vm_vars () {
   # -- Clears variables that vm.conf uses (ie; to avoid looping isses)
   VM_NAME=""
   VM_QUIRK=""
   VM_CPUS=""
   VM_MEMORY=""
   VM_ONBOOT=""
   VM_PRE_CMD=""
   VM_POST_CMD=""
   VM_BOOT_ZVOL=""
   VM_BOOT_PART="1"
   VM_DISK_FILES=""
   VM_GRUB_DIR=""
   VM_CDROM=""
   VM_CDROM_MEDIA=""
   AUTO_NETWORKING=""
   VM_FRAMEBUFFER=""
   VM_FRAMEBUFFER_OPTS=""
   VM_USB3=""

   for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
      PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
      eval $PREFIX_BRIDGE='';
      
      PREFIX_TAP="VM_N${j}_TAP_NUM"
      eval $PREFIX_TAP=''
   done
}

vml_check () {
   # Check to make sure there are no sourcing errors and no duplicate TAP devices
   out=`find_all_configs`;
   USED_TAPS="";
   RET="0";

   for vm in $out; do
      if ! sh $vm; then
         echo "${VM_NAME}: Syntax error in '${vm}'!";
         RET="1";
      else
         # -- Clear vars
         clear_vm_vars;
         
         # -- Now load VM config
         . $vm;
         for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
            PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
            BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
            PREFIX_TAP="VM_N${j}_TAP_NUM"
            TAP=`eval echo "\$""$PREFIX_TAP"`
            
            if [ "$TAP" != "" ]; then
               #echo "$vm - $TAP";
               USE_CHECK=`echo "${USED_TAPS}" | tr " " "\n" | grep "^${TAP}:"`;
               if [ -n "${USE_CHECK}" ]; then
                  DUPE_TAP_HOST=`echo ${USE_CHECK} | awk -F : '{print $2}'`;
                  echo ">> ERROR: TAP ${TAP} used by ${VM_NAME} and ${DUPE_TAP_HOST}";
                  RET="1";
               else
                  USED_TAPS="${USED_TAPS} ${TAP}:${VM_NAME}";
               fi
            fi
         done
      fi
   done

   #echo "Used taps: ${USED_TAPS}";
   return ${RET};
}

vml_check_cond_show () {
   if ! vml_check > /dev/null 2> /dev/null; then
      echo "";
      echo ">> ERROR: Configuration errors found:";
      vml_check;
      echo "";
   fi
}

NiceSize ()
{
   SIZE="$1";     # Value (in bytes)
   SCALE="$2";    # Decimal places (default is 1)
   UNIT="$3";     # Unit (default is auto-detect)

   # ---- Set default decimal places
   #
   if [ -z "${SCALE}" ]; then
      SCALE=1;
   fi

   # ---- Set default unit
   #
   if [ -z "${UNIT}" ]; then
      if [ "${SIZE}" -gt 1125899906842624 ]; then
         UNIT="PiB";
      elif [ "${SIZE}" -gt 1099511627776 ]; then
         UNIT="TiB";
      elif [ "${SIZE}" -gt 1073740800 ]; then
         UNIT="GiB";
      elif [ "${SIZE}" -gt 1048576 ]; then
         UNIT="MiB";
      elif [ "${SIZE}" -gt 1024 ]; then
         UNIT="KiB";
      else
         UNIT="byte";
      fi
   fi

   # ---- Convert to unit
   #
   if [ "${UNIT}" == "PiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1125899906842624" | bc`;
   elif [ "${UNIT}" == "TiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1099511627776" | bc`;
   elif [ "${UNIT}" == "GiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1073741824" | bc`;
   elif [ "${UNIT}" == "MiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1048576" | bc`;
   elif [ "${UNIT}" == "KiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1024" | bc`;
   elif [ "${UNIT}" == "byte" ]; then
      NICE_SIZE="${SIZE}";
   else
      NICE_SIZE="NiceSize: unknown unit \"${UNIT}\"";
   fi

   NICE_SIZE=`echo ${NICE_SIZE} | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev`;
   echo "${NICE_SIZE} ${UNIT}";
}

vml_get_tap_to_vm_map () {
   out=`find_all_configs`;
   # -- Loop through each VM, returning a sorted list of tapN:vmnames values
   RET=""
   for vm in $out; do
      clear_vm_vars;
      
      . $vm;
      for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
         PREFIX_TAP="VM_N${j}_TAP_NUM"
         TAP=`eval echo "\$""$PREFIX_TAP"`
         
         if [ -n "$TAP" ]; then
            USE_CHECK=`echo ${members} | tr " " "\n" | grep "tap${TAP}"`;
            if [ -n "${USE_CHECK}" ]; then
               RET="${RET} tap${TAP}:${VM_NAME}"
            fi
         fi
      done
   done
   
   echo "${RET}" | tr " " "\n" | sort -u
}

vml_get_tap_vm () {
   TAP_TO_FIND="$1";
   TAP_MAP="$2";
   
   if [ -z ${TAP_MAP} ]; then
      TAP_MAP=`vml_get_tap_to_vm_map`;
   fi
   
   RET=`echo "${TAP_MAP}" | tr " " "\n" | grep "^${TAP_TO_FIND}:" | awk -F : '{print $2}'`;
   
   echo "${RET}";
}

vml_get_tap_to_bridge_map() {
   # -- Loop through each bridge and then VM, returning a sorted list of dev:bridgeN values
   out=`find_all_configs`;
   bridges=`find_all_bridges`;
   
   RET="";
   
   # -- Loop through each bridge
   for bridge in $bridges; do
      members=`ifconfig $bridge | grep "member: " | awk '{print $2}' | sort -u`;
      
      if [ -n "${members}" ]; then
         # -- loop through taps
         for CUR_DEV in $members; do
            RET="${RET} ${CUR_DEV}:${bridge}"
         done
      fi
   done

   echo "${RET}";
}

vml_get_tap_bridge () {
   TAP_TO_FIND="$1";
   TAP_MAP="$2";
   
   if [ -z ${TAP_MAP} ]; then
      TAP_MAP=`vml_get_tap_to_bridge_map`;
   fi
   
   RET=`echo "${TAP_MAP}" | tr " " "\n" | grep "^${TAP_TO_FIND}:" | awk -F : '{print $2}'`;
   
   echo "${RET}";
}
   
vml_get_bridge_name () {
   bridge="$1";
   BRIDGE_NAME_VAR="BRIDGE_${bridge}_NAME";
   BRIDGE_NAME=`eval echo "\$""$BRIDGE_NAME_VAR"`;
   
   echo "${BRIDGE_NAME}"
}

vml_netmap () {
   vml_check_cond_show;
   
   out=`find_all_configs`;
   bridges=`find_all_bridges`;
   
   echo "Bridge To VM NIC Mappings";
   echo "";

   TAP_MAP=`vml_get_tap_to_vm_map`;
   
   # -- Loop through each bridge
   for bridge in $bridges; do
      members=`ifconfig $bridge | grep "member: " | awk '{print $2}' | sort -u`;
      
      if [ -n "${members}" ]; then
         echo -n "${bridge}";
         
         BRIDGE_NAME=`vml_get_bridge_name ${bridge}`;
         if [ -n "${BRIDGE_NAME}" ]; then
            echo " - ${BRIDGE_NAME}";
         else
            echo "";
         fi
         
         echo "  |";
         
         # -- loop through taps
         for CUR_DEV in $members; do
            CUR_VM_NAME=`vml_get_tap_vm "${CUR_DEV}" "${TAP_MAP}"`;
            
            # -- See if dmesg has dev info
            if [ -z "${CUR_VM_NAME}" ]; then
               CUR_VM_NAME=`grep "^${CUR_DEV}: " /var/run/dmesg.boot | awk -F '<' '{print $2}' | awk -F '>' '{print $1}' | grep -v "^$" | head -n 1`;
            fi
            
            # -- Display
            if [ -n "${CUR_VM_NAME}" ]; then
               printf "  +-- %5s -> %s\n" "${CUR_DEV}" "${CUR_VM_NAME}";
            else
               printf "  +-- %5s\n" "${CUR_DEV}";
            fi
         done
         
         echo "";
      else
         echo " ${bridge} - ";
         echo "";
      fi
   done

   #echo "Used taps: ${USED_TAPS}";
   return ${RET};
}

get_zpath () {
   ZPATH=`zfs list -o name,mountpoint | sed -e s:"//":"/":g | grep $SCRIPTPATH | cut -d " " -f1 | head -n 1`;
   if [ -z "${ZPATH}" ]; then
      fatal_error "Couldn't get ZPATH";
   else
      echo "${ZPATH}";
   fi
}

vml_info () {
   VM_CONF=`get_config_file_name "${VM_NAME}"`;
   
   if [ -z "${VM_CONF}" ]; then
      fatal_error "Couldn't find VM config file";
   fi
   
   . ${VM_CONF};
   
   NICE_VM_MEMORY=`NiceSize $(( ${VM_MEMORY} * 1024 * 1024 ))`;
   NICE_OS=`vml_quirk_to_text ${VM_QUIRK}`;
   
   echo "VM Name:       ${VM_NAME}";
   echo "OS:            ${NICE_OS}";
   echo "CPU Cores:     ${VM_CPUS}";
   echo "RAM:           ${NICE_VM_MEMORY}";
   echo "Auto-start:    ${VM_ONBOOT}";
   echo "";
   
   if [ -n "${VM_BOOT_ZVOL}" ]; then
      ZPATH=`get_zpath`
      VM_ZPOOL="${ZPATH}/${VM_BOOT_ZVOL}";
      SIZE=`zfs get -Hp volsize ${VM_ZPOOL} | awk '{print $3}'`
      USED=`zfs get -Hp logicalused ${VM_ZPOOL} | awk '{print $3}'`
      NICE_SIZE=`NiceSize ${SIZE}`;
      NICE_USED=`NiceSize ${USED}`;
      
      printf "%-14s %9s  %s\n" "Disk (ZVOL):" "${NICE_SIZE}" "${VM_ZPOOL} (${NICE_USED} on disk)";
   fi
   
   if [ -n "${VM_DISK_FILES}" ]; then
      for CUR_DISK_FILE_RAW in ${VM_DISK_FILES}; do
         # -- Expand relative if needed
         if echo "${CUR_DISK_FILE_RAW}" | grep "^/" > /dev/null; then
            CUR_DISK_FILE="${CUR_DISK_FILE_RAW}"
         else
            CUR_DISK_FILE="${SCRIPTPATH}/${CUR_DISK_FILE_RAW}";
         fi
         if [ -e "${CUR_DISK_FILE}" ]; then
            SIZE=`stat -f %z "${CUR_DISK_FILE}"`;
            NICE_SIZE=`NiceSize ${SIZE}`;
         else
            NICE_SIZE="--";
         fi
         
         printf "%-14s %9s  %s\n" "Disk (File):" "${NICE_SIZE}" "${CUR_DISK_FILE}";
      done
   fi
   
   echo "";
   for NIC_NO in 1 2 3 4 5 6 7 8 9 10 11 12; do
      PREFIX_TAP="VM_N${NIC_NO}_TAP_NUM"
      TAP_NO=`eval echo "\$""$PREFIX_TAP"`
      
      if [ -n "${TAP_NO}" ]; then
         TAP_DEV="tap${TAP_NO}";
         CUR_BRIDGE=`vml_get_tap_bridge "${TAP_DEV}"`;
         
         if [ -z "${CUR_BRIDGE}" ]; then
            echo "  NIC ${NIC_NO}: (${TAP_DEV})";
         else
            CUR_BRIDGE_NAME=`vml_get_bridge_name ${CUR_BRIDGE}`;
            if [ -z "${CUR_BRIDGE_NAME}" ]; then
               printf "NIC %-2s -> %-6s -> %s\n" "${NIC_NO}" "${TAP_DEV}" "${CUR_BRIDGE}";
            else
               printf "NIC %-2s -> %-6s -> %s (%s)\n" "${NIC_NO}" "${TAP_DEV}" "${CUR_BRIDGE_NAME}" "${CUR_BRIDGE}";
               #echo "NIC ${NIC_NO}: (${TAP_DEV}) -> ${CUR_BRIDGE_NAME} (${CUR_BRIDGE})";
            fi
         fi
      fi
   done
}

vml_list () {
   vml_check_cond_show

   out=`find_all_configs`;
   COL_FORMAT="%-20s %-13s %-7s %-6s %4s %7s %7s %11s\n";
   
   printf "${COL_FORMAT}" "Guest Name" "OS" "State" "Boot" "CPUs" "RAM" "Use" "Res";
   printf -- "---------------------------------------------------------------------------------- -\n";

   TOTAL_USED_CPU="0";
   TOTAL_USED_MEM="0";
   TOTAL_VM_MEMORY="0";
   
   for vm in $out; do
      . $vm
      TYPE=$( vml_quirk_to_text )
      vml_stat

      if [ "$?" == "1" ]; then
         STATE="On"
      else
         STATE="Off"
      fi

      if [ "${STATE}" == "On" ]; then
         USED_CPU=`ps aux -ww | grep "bhyve: $VM_NAME (bhyve)" | grep -v grep | awk '{print $3}' | awk -F . '{print $1}'`;
         if [ `id -u` -eq "0" ]; then
            USED_MEM_RAW=`bhyvectl --get-stats --vm=$VM_NAME | grep "^Resident memory" | awk '{print $3}'`;
            if [ -z "${USED_MEM_RAW}" ]; then
               USED_MEM_RAW="0";
            fi
            USED_MEM=`NiceSize ${USED_MEM_RAW} 1`;
            TOTAL_USED_MEM="$(( ${TOTAL_USED_MEM} + ${USED_MEM_RAW} ))";
         else
            USED_MEM="--";
         fi
      else
         USED_CPU="0";
         USED_MEM="--";
      fi

      if [ "${VM_ONBOOT}" == "YES" ]; then
         NICE_VM_ONBOOT="Auto";
      else
         NICE_VM_ONBOOT="Manual";
      fi

      VM_MEMORY=$(( ${VM_MEMORY} * 1024 * 1024 ));

      TOTAL_VM_MEMORY="$(( ${TOTAL_VM_MEMORY} + ${VM_MEMORY} ))";
      TOTAL_USED_CPU="$(( ${TOTAL_USED_CPU} + ${USED_CPU}))";

      VM_MEMORY=`NiceSize ${VM_MEMORY} 0`;
      
      printf "${COL_FORMAT}" "$VM_NAME" "$TYPE" "$STATE" "${NICE_VM_ONBOOT}" "$VM_CPUS" "$VM_MEMORY" "${USED_CPU}%" "$USED_MEM";
   done 

   NICE_TOTAL_USED_MEM=`NiceSize ${TOTAL_USED_MEM}`;
   NICE_TOTAL_VM_MEMORY=`NiceSize ${TOTAL_VM_MEMORY} 0`; 

   printf -- "---------------------------------------------------------------------------------- -\n";
   printf "${COL_FORMAT}" "" "" "" "" "" "${NICE_TOTAL_VM_MEMORY}" "${TOTAL_USED_CPU}%" "${NICE_TOTAL_USED_MEM}";
}

quick_padding () {
   LENGTH=`echo ${1} | wc -c | tr -d "\n"`
   PAD_CHAR=`expr ${2} - ${LENGTH}`
   for a in `seq 1 $PAD_CHAR`; do
      printf " "
   done
}

vml_rcstart () {

echo "bhyve management tool"


   # Kernel modules
   if [ "${bmt_kern_modules}" == "" ]; then
      bmt_kern_modules="vmm if_tap if_bridge"
      printf " * loading default kernel modules:\n"
   else
      printf " * loading user kernel modules: \n"
   fi


   for MOD in ${bmt_kern_modules}; do
      printf "     * ${MOD}"
      kldload $MOD > /dev/null 2>&1
      printf "$( quick_padding $MOD 20 )"
      echo "done"
   done

   # Sysctls
   if [ "${bmt_sysctls}" == "" ]; then
      bmt_sysctls="net.link.tap.up_on_open=1"
      printf " * loading default sysctls:\n"
   else
      printf " * loading user sysctls: \n"
   fi


   for MOD in ${bmt_sysctls}; do
      echo "     * ${MOD}"
      sysctl $MOD > /dev/null 2>&1
   done
      

#  sysctl net.link.tap.up_on_open=1

   # Virtual Machines
   out=`find_all_configs`;
   printf " * starting vms: \n"
   for vm in $out; do
      . $vm 

      if [ "$VM_ONBOOT" == "YES" ]; then
         printf "     * ${VM_NAME}"
         $SCRIPT start $VM_NAME
         printf "$( quick_padding $VM_NAME 20 )"
         echo "done"
      fi
   done
   echo "bmt init finished"   
}

vml_wait_for_poweroff(){
   while true; do
      vml_stat
      if [ "$?" == "0" ]; then   
         break 
      fi 
   done
}

vml_rcstop() {
   printf "bmt stopping all running vms: \n"
   out=`find_all_configs`;

   # Quick stop loop
      for vm in $out; do
         . $vm
      vml_stop -q 
   done

   # Wait for things to actually stop
   for vm in $out; do
      . $vm
      printf "     * ${VM_NAME}"
      while true; do
         vml_stat
         if [ "$?" == "0" ]; then   
            break 
         fi 
      done
      printf "$( quick_padding $VM_NAME 20 )"
      echo "done"
   done

   # Kernel modules
   if [ "${bmt_kern_modules}" == "" ]; then
      bmt_kern_modules="vmm if_tap if_bridge"
      printf " * unloading default kernel modules:\n"
   else
      printf " * unloading user kernel modules: \n"
   fi


   for MOD in ${bmt_kern_modules}; do
      printf "     * ${MOD}"
      kldunload $MOD > /dev/null 2>&1
      printf "$( quick_padding $MOD 20 )"
      echo "done"
   done



   printf "bmt shutdown finished\n"
}

vml_stop () {
   if [ "$ARG_FORCE" == "-f" ]; then
      bhyvectl --vm=$VM_NAME --force-poweroff
      bhyvectl --vm=$VM_NAME --destroy
   else
      vml_stat
      if [ "$?" == "1" ]; then
         tpid=`ps aux -ww | grep "bhyve: $VM_NAME (bhyve)" | grep -v grep | awk '{print $2}'`
         kill -TERM $tpid
      else
         if [ "$1" != "-q" ]; then
            echo "VM is not running"
         fi
      fi
   fi
}

vml_destroy () {
   ARG_FORCE="YES"
   vml_stop  
   zfs destroy -r $ZPATH
   echo "$VM_NAME destroyed"
}

vml_edit () {
   $EDITOR $VM_ROOT"/vm.conf"
}

vml_vm_exists () {
   if [ -f "${VM_LIVES}/${VM_NAME}/vm.conf" ]; then
      return 1
   else
      return 0
   fi 
}

vml_clone () {
   

   # If the VM is running, error and exit
   if [ "$FORCE" == "YES" ]; then
      vml_stop
      echo "Waiting for vm to poweroff..."
      vml_wait_for_poweroff
      echo "VM Powered off"
   else
      vml_stat
   
      if [ "$?" == "1" ]; then
         echo "VM is running. Use -f flag to shutdown before migration"
         exit
      fi
   fi 

   # Actually do the clone
   SNAPSHOT_NAME="`date +'%s'`_clone_${ARG_BONUS}"

   zfs snapshot -r ${ZPATH}@${SNAPSHOT_NAME}
   zfs clone ${ZPATH}@${SNAPSHOT_NAME} ${BASE_ZPATH}/$ARG_BONUS
   # Clone all of the zvols into their destination
   for ds in `zfs list -r -H -t volume -o name $ZPATH`
   do
      DS_NAME=${ds##*/}
      zfs clone ${ds}@${SNAPSHOT_NAME} ${BASE_ZPATH}/${ARG_BONUS}/${DS_NAME}
   done

   # Rename the VM in the configuration file
   sed -i -- "s/VM_NAME=\"${VM_NAME}\"/VM_NAME=\"${ARG_BONUS}\"/g" ${VM_LIVES}/${ARG_BONUS}/vm.conf
   rm ${VM_LIVES}/${ARG_BONUS}/vm.conf--  
}

vml_rename () {
   vml_stat

   if [ "$?" == "1" ]; then
      echo "The VM cannot be renamed while running"
      exit
   fi

   VM_NAME_TEMP="${VM_NAME}"
   VM_NAME="${ARG_BONUS}"
   vml_require_no_exist
   VM_NAME="${VM_NAME_TEMP}"

   zfs rename ${ZPATH} ${BASE_ZPATH}/${ARG_BONUS}
   sed -i -- "s/VM_NAME=\"${VM_NAME}\"/VM_NAME=\"${ARG_BONUS}\"/g" ${VM_LIVES}/${ARG_BONUS}/vm.conf
   rm ${VM_LIVES}/${ARG_BONUS}/vm.conf--  
}

vml_send () {
   # -- Make sure this VM has no zvols that are clones (and thus won't copy)
   VM_ZVOL_LIST=`zfs list -o name | egrep "^${ZPATH}(/|$)"`;
   for CUR_ZVOL in ${VM_ZVOL_LIST}; do
       CUR_ORIGIN=`zfs get -H -o value origin ${CUR_ZVOL}`;
       if [ "${CUR_ORIGIN}" != "-" ]; then
	  fatal_error "${CUR_ZVOL} is a clone of another zvol or is the source of another clone.   Sending it somewhere isn't going to work because its reference will be missing.  Use 'zfs promote ${CUR_ZVOL}' to detach it from it's base and send again.  You may need to run that command multiple times if it's a nested clone.";
       fi
   done
   if [ "$FORCE" == "YES" ]; then
      vml_stop
      echo "Waiting for vm to poweroff..."
      vml_wait_for_poweroff
      echo "VM Powered off"
   else
      vml_stat
   
      if [ "$?" == "1" ]; then
         echo "VM is running. Use -f flag to shutdown before migration"
         exit
      fi
   fi 

   # Actually do the export
   SNAPSHOT_NAME="`date +'%s'`_send"

   zfs snapshot -r ${ZPATH}@${SNAPSHOT_NAME}
   zfs send -R ${ZPATH}@${SNAPSHOT_NAME}
#  zfs send -vR ${ZPATH}@${SNAPSHOT_NAME}
}

vml_require_no_exist () {
   vml_vm_exists
   if [ "$?" == "1" ]; then
      echo "VM ${VM_NAME} already exists."
      exit
   fi
}

vml_require_exist () {
   vml_vm_exists
   if [ "$?" == "0" ]; then
      echo "VM ${VM_NAME} doesn't exist"
      exit
   fi

}

vml_require_off () {
   vml_stat
   if [ "$?" == "1" ]; then
      echo "VM ${VM_NAME} cannot be running"
      exit
   fi
}

vml_receive () {
   vml_require_no_exist
   zfs receive ${BASE_ZPATH}/${VM_NAME}
   OLD_VM_NAME=`cat ${VM_LIVES}/${VM_NAME}/vm.conf | grep VM_NAME`
   sed -i -- "s/${OLD_VM_NAME}/VM_NAME=\"${VM_NAME}\"/g" ${VM_LIVES}/${VM_NAME}/vm.conf
   
}

vml_help () {
   vml_usage
}

vml_usage (){
   echo "
USAGE:
bmt attach <vm_name>
bmt check
bmt create <vm name> [ -V VOLSIZE[K,M,G,T etc ]
bmt clone <vm name> <new vm name>
bmt destroy <vm_name>
bmt edit <vm_name>
bmt info <vm_name>
bmt list 
bmt rcstart
bmt rcstop
bmt get <vm name> <CONFIG_VAR>
bmt set <vm name> <CONFIG_VAR> <new value>
bmt netmap
bmt receive [new_vm_name]
bmt rename <current vm name> <new vm name>
bmt send <vm_name>
bmt start <vm_name> [ -d ]
bmt status <vm_name>
bmt stop <vm_name> [ -f ]"
}

vml_get() {
   vml_getreal ${VM_NAME} ${ARG_BONUS}
}

vml_getreal () {
   VM_NAME=${1}
   ARG_BONUS=${2}
   
   # make sure that variable exists in the config
   if [ "`grep ${ARG_BONUS}= ${VM_LIVES}/${VM_NAME}/vm.conf | wc -l | tr -d " "`" == 1 ]; then
      echo `cat ${VM_LIVES}/${VM_NAME}/vm.conf | grep ${ARG_BONUS} | tr -d " " | cut -d = -f2 | tr -d \" | cut -d \# -f1`
   else
      echo "unset"
   fi

}

vml_setreal () {
   VM_NAME=${1}
   ARG_BONUS=${2}
   ARG_VAL=${3}
   CUR_VAL=$( vml_getreal ${VM_NAME} ${ARG_BONUS} )  
   if [ "`grep ${ARG_BONUS}= ${VM_LIVES}/${VM_NAME}/vm.conf | wc -l | tr -d " "`" == 1 ]; then
      # Setting already exists, so we need to replace it dynamically.
      sed -i.bak "s/${ARG_BONUS}=\"${CUR_VAL}\"/${ARG_BONUS}=\"${ARG_VAL}\"/g" ${VM_LIVES}/${VM_NAME}/vm.conf

   else

      echo "${ARG_BONUS}=\"${ARG_VAL}\"" >> ${VM_LIVES}/${VM_NAME}/vm.conf
      echo "${VM_NAME} ${ARG_BONUS}= [unset] => ${ARG_VAL}"
   fi

}

vml_set (){
   vml_setreal ${VM_NAME} ${ARG_BONUS} ${ARG_VAL}
}
vml_create () {
   # Syntax
   # bmt create [ vm ] [ bonus ( volume size) 
   ZVOL_SIZE="10G";

   if [ "${ARG_BONUS}"x == "-V"x ]; then
      if [ -n "${ARG_BONUS2}" ]; then
         ZVOL_SIZE="${ARG_BONUS2}";
      else
         fatal_error "Missing flag param: 'create -V <volsize>'";
      fi
   fi
   
   if ! zfs create "${BASE_ZPATH}/$VM_NAME"; then
      fatal_error "Couldn't create zvol '$BASE_ZPATH/$VM_NAME'";
   fi
   if ! zfs create -V "$ZVOL_SIZE" -o refreservation=none "$BASE_ZPATH/$VM_NAME/disk"; then
      fatal_error "Couldn't create zvol '$BASE_ZPATH/$VM_NAME/disk'";
   fi
   
   echo "#!/bin/sh

# -- VM Basics
#
VM_NAME=\"$VM_NAME\""'
VM_QUIRK="0"         # - See OS Type list below
VM_CPUS="1"          # - Number of virtual CPUs
VM_MEMORY="1024"     # - Guest RAM allocation
VM_ONBOOT="YES"      # - Start this VM when the host boots
VM_PRE_CMD=""        # - Command to run before starting
VM_POST_CMD=""       # - Command to run after exiting

# -- Booting / Disks
#
VM_BOOT_ZVOL="disk"  # - The zvol sub-name to boot from
VM_BOOT_PART="1"     # - The partition to boot from
VM_DISK_FILES=""     # - Disk-file alternative to BOOT_ZVOLs
VM_GRUB_DIR=""       # - Override the grub dir (ie; /grub2 for LVM)
                     #   (normally dictated by VM_QUIRK logic)

# -- CD/DVD Media
#
VM_CDROM="0"
VM_CDROM_MEDIA=""

# -- File-based Disk(s)
#

# -- Networking
#  ( Up to 12 NIC are possible following the same naming convention )
#
AUTO_NETWORKING="YES"
VM_N1_BRIDGE_NUM=""
VM_N1_TAP_NUM=""

VM_N2_BRIDGE_NUM=""
VM_N2_TAP_NUM=""

# -- Framebuffer
#
VM_FRAMEBUFFER="0"
VM_FRAMEBUFFER_OPTS="tcp=0.0.0.0:5900,wait"

# -- USB 3.0
#
VM_USB3="0"

# -- OS Type 
#  0 FreeBSD
#  1 CentOS 6.x
#  2 CentOS 7.x
#  3 Ubuntu 15.04
#  4 Fedora 23
#  5 Arch
#  6 NetBSD
#  7 OpenBSD 5.8
#  8 Windows 10
#' > "$VM_LIVES/$VM_NAME/vm.conf"
   echo "VM '${VM_NAME}' created";
}

vml_setup () {
   mkdir -p ${VM_LIVES} && 
   zfs create -o compression=lz4 -o mountpoint=${VM_LIVES} ${BASE_ZPATH}
}

vml_quirk_to_text () {

   case $VM_QUIRK in
      0) VM="FreeBSD";;
      1) VM="CentOS 6";;
      2) VM="CentOS 7";;
      3) VM="Ubuntu";;
      5) VM="Arch";;
      6) VM="NetBSD";;
      7) VM="OpenBSD";;
      8) VM="Windows 10";;
      *) VM="UNKNOWN";;
   esac
   echo "${VM}"

}

vml_sanity () {
   # These are the required binaries
   REQUIRED_BINARIES="screen"

   for bin in $REQUIRED_BINARIES; do
      if [ ! -f "`whereis -qb ${bin}`" ]; then
         echo "${bin} not installed, and it is required"
         FATAL="YES"
      fi
   done

   # These are the optional binaries
   OPTIONAL_BINARIES="grub-bhyve ext4fuse"

   for bin in $OPTIONAL_BINARIES; do
      if [ ! -f "`whereis -qb ${bin}`" ]; then
         echo "${bin} not installed, but it is optional"
      fi
   done

   if [ "${FATAL}" == "YES" ]; then
      echo "There were fatal errors"
      exit
   fi

   # Is the ZPATH set up yet?
   BASE_ZPATH=`zfs get bvm: | grep -v inherited | grep yes | head -n 1 | cut -d " " -f 1`
   if [ "${BASE_ZPATH}" == "" ]; then
      echo "BMT does not appear to be set up yet. Please run bmt setup."
      exit
   fi

}

############################################## MAIN

# check setup
#vml_sanity



# Argument Handling
# bmt [ action ] [ vm ] [ bonus ] 
# bmt create [ vm ] 

# Flags
for arg in $*
do
   case $arg in


      f)
         ARG_FORCE="YES"
      ;;

      is)
         # This hack allows the start command to launch screens without looping
         IN_SCREEN="YES"
         echo "IN SCREEN DETECTED"
      ;;

      q) 
         ARG_QUIET="YES"
      ;;

      c)
         echo "Clear"
      ;;

      
   esac

done


# Where are we executing from?
SCRIPT=$(readlink -f "$0")

# Argument $1, action
   
   # Check if the first argument is set
   ARG_ACTION="$1"
   if [ "$ARG_ACTION" == "" ]; then
      echo "Argument action not provided"
      vml_usage
      exit
   fi

   # Make sure a valid action is provided
   case $ARG_ACTION in
      help)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;
      
      attach)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      clone)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;

      create)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         if [ "$2" == "" ]; then
            echo "No vm name provided to create"
            exit
         else
            VM_NAME=$2
         fi
         ROOT_REQUIRED="YES"
      ;;

      destroy)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;


      edit)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      get)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      check)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;
      
      netmap)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      info)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;

      list)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      rcstart)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="YES"
      ;;

      rcstop)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="YES"
      ;;

      receive)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         VM_NAME="${2}"
         ROOT_REQUIRED="NO"
      ;;
   
      rename)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      sanity)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      send)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
      
      set)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
         if [ "${4}" == "" ]; then
            echo "Value argument not set."
            exit 1;
         else
            ARG_VAL=${4}
         fi
      ;;
   
      setup)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         SETUP_POOL="zroot"
         ROOT_REQUIRED="YES"
      ;;
   
      start)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      status)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;

      stop)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
         if [ "$3"=="-f" ]; then
            ARG_FORCE="-f"
         fi
      ;;

      vm_exists)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         VM_NAME="${2}"
         ROOT_REQUIRED="NO"
      ;;

      wait_for_poweroff)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
   
      *)
         echo "$ARG_ACTION is an invalid action"
         vml_usage
         exit 1;
      ;;
   esac  

# Are we root?
if [ "${ROOT_REQUIRED}" == "YES" ]; then
   if [ "`whoami | tr -d \"\\n\"`" != "root" ]; then
      echo "The $ARG_ACTION action requires root"
      exit 1;
   fi
fi
      
# Deal with the VM_NAME, if necessary
if [ "$VM_REQUIRED" == "YES" ] ; then
   VM_NAME=$2

   if [ "$VM_NAME" == "" ]; then
      echo "No vm name provided"
      exit 1;
   fi

   vml_require_exist

   # Source the configuration
   VM_ROOT="${VM_LIVES}/${VM_NAME}"

   if ! [ -d "${VM_ROOT}" ]; then
      fatal_error "Invalid VM_ROOT \"${VM_ROOT}\"";
   fi

   if ! [ -r "${VM_ROOT}/vm.conf" ]; then
      fatal_error "vm.conf missing from ${VM_ROOT}";
   fi

   . "${VM_ROOT}/vm.conf"

   SCRIPTPATH="$VM_ROOT"
   ZPATH=`get_zpath`

   if [ -z "${ZPATH}" ]; then
      echo " >>> ERROR: Could not establish ZPATH for $VM_ROOT";
      exit 1;
   fi

fi

# Deal with bonus $3
if [ -n "$3" ]; then
   ARG_BONUS="$3"
fi
if [ -n "$4" ]; then
   ARG_BONUS2="$4"
fi

if [ "$BONUS_REQUIRED" == "YES" -a -z "${ARG_BONUS}" ]; then
   echo "Not enough arguments"
   exit 1;
fi

# Early escape if we are listing
#if [ "$1" == "list" ] || [ "$1" == "rcstart" ] || [ "$1" == "rcstop" ]; then
#  vml_$1 $@
#  exit
#fi

# Early escape if we are creating
#if [ "$2" == "create" ] ; then
#  vml_$2 $@
#  exit
#fi


vml_$ARG_ACTION
RET_VAL=$?

exit ${RET_VAL}
