#!/bin/sh

#
# BMT - Bhyve Management Tool
#
# Created by Steven Douglas /w improvements by Adam Strohl
#

# Script Version
VERSION="0.1.43"

# What directory do the vms live in?
VM_LIVES="/usr/local/vms"

# Set to '-S' to wire memory (experimental) for PCI Pass through
WIRE_SWITCH="";

# Where to start generating tap devices when AUTO_NETWORKING is used and no VM tap is specified manually
TAP_START="20";

# How long to wait (in seconds) between VM starts on boot.  I found there are clock issues with the guests if too many start at once so increasing this to 10-20 seconds fixes it
RC_START_VM_DELAY="1";

# Sanity limit to auto-tap generation
TAP_MAX="200";

# Base zpath hack
BASE_ZPATH="zroot/vms"

# Runtime stuff
RUN_DIR="/var/run/bmt"

# Load config file if present
if [ -r "/usr/local/etc/bmt.conf" ]; then
   . /usr/local/etc/bmt.conf;
fi

# Setup a space to log what tap/bridges are allocated for netmap
VM_STATE_DIR="${RUN_DIR}/vmstate"
mkdir -p ${VM_STATE_DIR} > /dev/null;

vml_start () {
      VM_STATE_FILE="${VM_STATE_DIR}/${VM_NAME}.state";
      if [ "${ARG_BONUS}" == "-d" ]; then
         BMT_DEBUG="YES"; 
      fi
      
      SCREEN_LOGGING_FLAGS="";
      if [ -n "${VM_CONSOLE_LOG}" ]; then
         SCREEN_LOGGING_FLAGS="-L -Logfile ${VM_CONSOLE_LOG}";
      fi
      
      # Screen
      if [ "$IN_SCREEN" != "YES" -a -z "${BMT_DEBUG}" ]; then
         if [ -z "${BMT_DEBUG}" ]; then
            `/usr/local/bin/screen ${SCREEN_LOGGING_FLAGS} -dmS bhyve."$VM_NAME" "$SCRIPT" start $VM_NAME is &`
            exit;
         else
            echo "Debugging mode enabled, not launching in screen";
            `"$SCRIPT" start $VM_NAME is &`;
            exit;
         fi
      fi
      sys_log "${VM_NAME}: start command running";
      
      # Reboot loop
      while [ 1 ]; do
         sys_log "${VM_NAME}: initializing";
         mutex_lock BMTVMStart;
         echo -n > ${VM_STATE_FILE};
         AUTO_NETWORKING_GEN_INTS="" # List of interfaces auto-created <interface>:<bridge>
         
         # Execute the pre command
         if [ "${VM_PRE_CMD}" != "" ]; then
            `${VM_PRE_CMD}`
         fi

         # Destroy any existing VM's with my name
         bhyvectl --vm=$VM_NAME --destroy 2> /dev/null

         # Figure out the PCI devices
         FINAL_PCI=""
         I=2
         
         # Default to virtio-net
         if [ -z "${VM_NET_DRIVER}" ]; then
            VM_NET_DRIVER="virtio-net";
         fi         

       # Default to MBR
       if [ -z "${VM_BOOT_PART_TYPE}" ]; then
          VM_BOOT_PART_TYPE="msdos";
       fi
         # Networking Devices
         for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
            PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
            BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
            PREFIX_TAP="VM_N${j}_TAP_NUM"
            TAP=`eval echo "\$""$PREFIX_TAP"`
            CUR_NIC_NO="${j}";
            
            if [ "$AUTO_NETWORKING" == "YES" ]; then
               if [ -n "${BRIDGE}" ]; then
                  if [ -z "${TAP}" ]; then
                     # No tap specified, allocate a new one
                     TAP=`get_next_free_tap`
                     if [ -z "${TAP}" ]; then
                        fatal_error "Couldn't allocate free tap (${TAP})"
                     else
                        echo "VM:${VM_NAME} NIC #${CUR_NIC_NO} (${VM_NET_DRIVER}) assigned tap${TAP} to bridge${BRIDGE}";
                     fi
                  fi
                  
                  if [ -n "$TAP" ]; then
                     # -- Create specified tap
                     ifconfig tap${TAP} create;
                     AUTO_NETWORKING_GEN_INTS="${AUTO_NETWORKING_GEN_INTS} ${TAP}:${BRIDGE}";
                     
                     # -- Record what was allocated into the state file so it can be sourced later
                     #    for stuff like 'bmt netmap'
                     #
                     # This could probably be safely moved out of the
                     # AUTO_NETWORKING==YES if and down to the FINAL_PCI area
                     echo "VM_N${CUR_NIC_NO}_BRIDGE_NUM=${BRIDGE}" >> ${VM_STATE_FILE};
                     echo "VM_N${CUR_NIC_NO}_TAP_NUM=${TAP}" >> ${VM_STATE_FILE};
                     
                     sys_log "${VM_NAME}: auto-creating tap${TAP} to bridge${BRIDGE} for NIC ${CUR_NIC_NO}";
                     
                     CUR_NIC_NO=$((CUR_NIC_NO+1))
                  fi
               fi
            fi
            
            # -- Add to bridge
            if [ -n "$TAP" ]; then
               if [ -z "${BRIDGE}" ]; then
                  fatal_error "tap${TAP} has no associated bridge, check VM config for VM_N${CUR_NIC_NO}_BRIDGE_NUM";
               fi
               ifconfig bridge$BRIDGE addm tap$TAP
               FINAL_PCI=$FINAL_PCI" -s $I,${VM_NET_DRIVER},tap$TAP "
               I=$((I+1))
            fi
            
         done

         # Scrape any zvols from our current dataset as disks
         echo "(hd0) /dev/zvol/$ZPATH/$VM_BOOT_ZVOL" > $SCRIPTPATH/device.map
         if [ "$VM_CDROM" == "1" ] ; then
            echo "(cd0) $VM_CDROM_MEDIA" >> $SCRIPTPATH/device.map
            FINAL_PCI=$FINAL_PCI" -s $I,ahci-cd,$VM_CDROM_MEDIA "
            I=$((I+1))
            BOOT_DEVICE="cd0"
         else
            BOOT_DEVICE="hd0,$VM_BOOT_PART_TYPE"$VM_BOOT_PART
         fi
         for ds in `zfs list -r -H -t volume -o name $ZPATH`
         do
           FINAL_PCI=$FINAL_PCI" -s $I,ahci-hd,/dev/zvol/$ds "
           echo "Adding disk (zvol) $ds"
           I=$((I+1))
         done

         # Get pci passthru devices
         for pci_dev in $VM_PCI_PT; do
           FINAL_PCI=$FINAL_PCI" -s $I,passthru,${pci_dev} "
           echo "Adding PCI PT ${pci_dev}"
           I=$((I+1))
         done
         
         # Add file-based disks
         for ds in ${VM_DISK_FILES}
         do
           FINAL_PCI=$FINAL_PCI" -s $I,ahci-hd,$ds "
           echo "Adding disk (file) $ds"
           I=$((I+1))
         done
         
         # Add Framebuffer
         if [ "$VM_FRAMEBUFFER" == "1" ] ; then
            FINAL_PCI=$FINAL_PCI" -s $I,fbuf,$VM_FRAMEBUFFER_OPTS "
            I=$((I+1))
         fi
         
         # Add USB 3.0
         if [ "$VM_USB3" == "1" ] ; then
            FINAL_PCI=$FINAL_PCI" -s $I,xhci,tablet "
            I=$((I+1))
         fi

         # Make sure that FreeBSD can see the boot vol's partitions
         gpart list zvol/${ZPATH}/${VM_BOOT_ZVOL} >> /tmp/caker
         
         # -- This is so auto-TAPs and other things don't run concurrently
         mutex_unlock BMTVMStart;
         sys_log "${VM_NAME}: starting";

         # FreeBSD
         if [ "$VM_QUIRK" == "0" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               bhyveload ${WIRE_SWITCH} -d $VM_CDROM_MEDIA -m $VM_MEMORY"M" $VM_NAME
            else
               bhyveload ${WIRE_SWITCH} -d "/dev/zvol/$ZPATH/$VM_BOOT_ZVOL" -m $VM_MEMORY"M" $VM_NAME
            fi
         # Quirk CentOS 6.x
         elif [ "$VM_QUIRK" == "1" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/isolinux/vmlinuz" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/isolinux/initrd.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               # Generate grub.cfg
               MOUNTPOINT="/tmp/$VM_NAME"
               if ! mkdir $MOUNTPOINT; then
                  fatal_error "Couldn't create temporary mountpoint for grub.cfg generation (${MOUNTPOINT})";
               fi
               
               if ! fuse-ext2 -o rw+ /dev/zvol/$ZPATH/$VM_BOOT_ZVOL"s"$VM_BOOT_PART $MOUNTPOINT; then
                  rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't mount boot partition with fuse";
               fi
               
               if ! VMLINUZ_PATH=`find "$MOUNTPOINT/boot/" \( ! -name '.*' \) -type f -name "vmlinuz*" | sed -e "s,$MOUNTPOINT,,g" | sort | tail -n 1`; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't run find operation for vmlinuz file";
               fi
               
               if [ -z "${VMLINUZ_PATH}" ]; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't find vmlinuz file in guest disk /boot";
               fi
               
               if ! INITRAMFS_PATH=`find "$MOUNTPOINT/boot/" \( ! -name '.*' \) -type f -name "initramfs*" | sed -e "s,$MOUNTPOINT,,g " | sort | tail -n 1`; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't run find operation for initramfs file";
               fi

               if [ -z "${INITRAMFS_PATH}" ]; then
                  umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";
                  fatal_error "Couldn't find initramfs file in guest disk /boot";
               fi
               
               umount "$MOUNTPOINT"; rmdir "$MOUNTPOINT";

               rm $SCRIPTPATH/grub.cfg
               echo "set root=($BOOT_DEVICE)" >> $SCRIPTPATH/grub.cfg
               echo "linux (hd0,$VM_BOOT_PART_TYPE$VM_BOOT_PART)$VMLINUZ_PATH root=/dev/sda""$VM_BOOT_PART" >> $SCRIPTPATH/grub.cfg
               echo "initrd (hd0,$VM_BOOT_PART_TYPE$VM_BOOT_PART)$INITRAMFS_PATH" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg


               # Run Grub
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi
         # Quirk CentOS 7.x
         elif [ "$VM_QUIRK" == "2" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/isolinux/vmlinuz" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/isolinux/initrd.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               if [ -z "${VM_GRUB_DIR}" ]; then
                  VM_GRUB_DIR="/boot/grub2";
               fi
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk Ubuntu
         elif [ "$VM_QUIRK" == "3" ]; then
            if [ -z "${VM_GRUB_DIR}" ]; then
               VM_GRUB_DIR="/boot/grub";
            fi
            /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

         # Quirk Fedora 
         elif [ "$VM_QUIRK" == "4" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} -d /isolinux/ -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            else
               if [ -z "${VM_GRUB_DIR}" ]; then
                  VM_GRUB_DIR="/grub2";
               fi
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} -d ${VM_GRUB_DIR} -r $BOOT_DEVICE -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk arch         
         elif [ "$VM_QUIRK" == "5" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_201601" >> $SCRIPTPATH/grub.cfg
               echo "initrd (cd0)/arch/boot/x86_64/archiso.img" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk NetBSD 
         elif [ "$VM_QUIRK" == "6" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
#              echo "set root=(cd0)" >> $SCRIPTPATH/grub.cfg
               echo "knetbsd -h -r cd0a (cd0)/netbsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               rm $SCRIPTPATH/grub.cfg
               echo "knetbsd -h -r wd0a (${BOOT_DEVICE})/netbsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk OpenBSD
         elif [ "$VM_QUIRK" == "7" ]; then
            if [ "$VM_CDROM" == "1" ]; then
               rm $SCRIPTPATH/grub.cfg
               echo "kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME

            else
               rm $SCRIPTPATH/grub.cfg
               echo "kopenbsd -h com0 -r sd0a (hd0,openbsd${BOOT_PART})/bsd" >> $SCRIPTPATH/grub.cfg
               echo "boot" >> $SCRIPTPATH/grub.cfg
               /usr/local/sbin/grub-bhyve ${WIRE_SWITCH} --directory=$SCRIPTPATH -m $SCRIPTPATH/device.map -M $VM_MEMORY $VM_NAME
            fi

         # Quirk Windows10
         elif [ "$VM_QUIRK" == "8" ]; then
            #echo "Windows 10 ... nothing to do :P"
            USE_BOOTROM="-l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd";
         else
            echo "VM_QUIRK NOT SET"
         fi

         sys_log "${VM_NAME}: started"
         /usr/sbin/bhyve ${WIRE_SWITCH} -c $VM_CPUS -m $VM_MEMORY"M" -A -H -w -s 0,hostbridge -s 31,lpc $FINAL_PCI -l com1,stdio $USE_BOOTROM $VM_NAME
         bhyve_exit=$?
         sys_log "${VM_NAME}: stopped"
         
         # Clean up the vm, its time to destroy it.
         bhyvectl --vm=$VM_NAME --destroy 2> /dev/null

         # Tidy up any auto networking that was done
         for PAIR in ${AUTO_NETWORKING_GEN_INTS}; do
            TAP=`echo "${PAIR}" | awk -F : '{print $1}'`;
            BRIDGE=`echo "${PAIR}" | awk -F : '{print $2}'`;
            sys_log "${VM_NAME}: releasing tap${TAP}"
            
            echo "VM:${VM_NAME} disconnecting tap${TAP} from bridge${BRIDGE}"
            ifconfig bridge${BRIDGE} deletem tap${TAP} #2> /dev/null
            
            echo "VM:${VM_NAME} removing tap${TAP}"
            ifconfig tap${TAP} destroy #2> /dev/null
         done

         # Only loop if the exit code was 0 (reboot)
         if [ $bhyve_exit -ne 0 ]; then
            sys_log "${VM_NAME}: guest shutdown detected";
            echo "VM Shutdown detected, not looping."
            break
         else
            sys_log "${VM_NAME}: guest reboot detected";
            echo "VM Reboot detected, looping"
            # -- Re-read the config file in case it's changed
            . "${VM_ROOT}/vm.conf";
         fi
      done

   rm "${VM_STATE_FILE}";
   
   if [ "${VM_POST_CMD}" != "" ]; then
      `${VM_POST_CMD}`
   fi
}

vml_stat() {
#  bhyvectl --vm=$VM_NAME --get-all | wc -l | tr -d " " | tr -d "\n"
   if [ "`bhyvectl --vm=$VM_NAME --get-all 2>&1 | wc -l | tr -d " " | tr -d "\n"`" == "1" ]; then
      return 0
   else
      return 1
   fi
}

vml_attach(){
   vml_stat
   if [ "$?" == "1" ]; then
      screen -r bhyve."$VM_NAME"
   else
      echo "VM is not running"
   fi

}

vml_status(){
   vml_stat
   if [ "$?" == "1" ]; then
      echo "VM is running"
   else
      echo "VM is not running"
   fi

}

fatal_error() {
   MESSAGE="${1}";
   sys_log "FATAL ERROR: ${MESSAGE}";
   echo " >>> ERROR: ${MESSAGE}";
   echo " >>> Exiting.";
   exit 1;
}

interface_exists() {
   INT="$1";
   if [ -z ${INT} ]; then
      return 1
   fi
   
   if ifconfig ${INT} > /dev/null 2> /dev/null; then
      return 0
   else
      return 1
   fi
}

get_next_free_tap() {
   CUR_TRY=${TAP_START};
   while [ ${CUR_TRY} -le ${TAP_MAX} ]; do
      if ! interface_exists "tap${CUR_TRY}"; then
         echo "${CUR_TRY}";
         return
      fi
      CUR_TRY=$((CUR_TRY+1));
   done
   # Return nothing if error
}   

find_all_configs () {
   LIST=`find $VM_LIVES | grep "/vm.conf$" | sort -V -t . -k 2 -k 1`;
   echo "${LIST}";
}

get_config_file_name () {
   VM_NAME="$1";
   
   CONF_FILE="${VM_LIVES}/${VM_NAME}/vm.conf";
   
   if [ -e "${CONF_FILE}" ]; then
      echo "${CONF_FILE}";
   fi
}

find_all_bridges () {
   LIST=`ifconfig -a | egrep "^bridge[0-9]+:" | awk -F : '{print $1}'`;
   echo "${LIST}";
}

#
# Writes entry to syslog
#
sys_log () {
   MESSAGE="$1";
   LOG_LEVEL="$2";

   if [ -z "${SYSLOG_APPNAME}" ]; then
      # -- Default to script's filename
      SYSLOG_APPNAME="${0##*/}[$$]";
   fi
   if [ -z "${LOG_LEVEL}" ]; then
      # - Default to notice
      LOG_LEVEL="notice";
   fi

   logger -p local0.${LOG_LEVEL} -t "${SYSLOG_APPNAME}" "${MESSAGE}";
}

#
# Generic Mutex Lock
#
mutex_lock () {
   MUTEXNAME="$1";
   RUNMUTEXDIR="/tmp";

   LOCKDIR="${RUNMUTEXDIR}/${MUTEXNAME}";
   PIDFILE="${LOCKDIR}/pid";
   #sys_log "obtaining lock ${MUTEXNAME} ...";

   #
   # Based on awesome inspiration from http://wiki.bash-hackers.org/howto/mutex
   #

   NO_PID_FILE_COUNT="0";
   LOCK_WAIT="0";
   while ! mkdir "${LOCKDIR}" 2> /dev/null;
   do
      # ---- Lock failed
      #
      if ! [ -e "${PIDFILE}" ]; then
         ls -l ${PIDFILE};
         # ---- No PID file yet
         #      This can actually happen with high concurrency, on alert on the 12th failure
         #      which gives the process that got the lock 3 seconds to write it's PID
         #      before logging this as a warning
         
         NO_PID_FILE_COUNT=$(( NO_PID_FILE_COUNT + 1 ));
         if [ ${NO_PID_FILE_COUNT} -ge 12 ]; then
            #log_write "couldn't get PID of process that has lock on ${LOCKDIR} even after waiting 3 seconds, exiting";
            sys_log "WARNING: couldn't get PID of process that has lock on ${LOCKDIR} even after waiting ${NO_PID_FILE_COUNT} seconds, exiting";
            echo "BMT WARNING: couldn't get PID of process that has lock on ${LOCKDIR} even after waiting ${NO_PID_FILE_COUNT} seconds, exiting";
            exit 1;
         fi
      else
         # ---- There is a PID file
         #
         NO_PID_FILE_COUNT="0";

         LOCK_WAIT=$(( LOCK_WAIT + 1 ));
         if [ ${LOCK_WAIT} -ge 60 ]; then
            sys_log "WARNING: couldn't get lock for ${MUTEXNAME} after waiting ${LOCK_WAIT} seconds, exiting";
            echo "BMT WARNING: couldn't get lock for ${MUTEXNAME} after waiting ${LOCK_WAIT} seconds, exiting";
            exit 1;
         fi
         
         OTHERPID=`cat "${PIDFILE}" 2> /dev/null`;
         if [ -n "${OTHERPID}" ]; then
            # --- Check to see if the PID is running
            if ! kill -0 ${OTHERPID} 2> /dev/null;
               then
               # --- Stale lockfile
               sys_log "removing stale PID lock file for ${MUTEXNAME}";
               rm -rf "${LOCKDIR}";
               # --- Next loop should catch this
            else
               # --- Process is still running, wait a second before checking again
               echo "BMT: waiting for ${MUTEXNAME} lock";
               sys_log "waiting for ${MUTEXNAME} lock";
               sleep 1;
            fi
         else
            # -- OTHERPID is blank
            # -- Make sure the file is still there
            if [ -e "${PIDFILE}" ]; then
               # -- It is, something is messed
               #log_write "PID lock file exists ${PIDFILE} but is empty!";
               sys_log "WARNING: PID lock file exists for ${MUTEXNAME} but is empty";
               echo "BMT WARNING: PID lock file exists ${MUTEXNAME} but is empty!";
            fi
         fi
      fi
   done
   
   # --- Output PID
   echo "$$" >"${PIDFILE}"; 
   
   # --- Lock succeeded
   #log_write "lock ${MUTEX_NAME} obtained";
}

mutex_unlock () {
   MUTEXNAME="$1";
   RUNMUTEXDIR="/tmp";

   if [ -z "${RUNMUTEXDIR}" ]; then
      fatal_error "mutex_unlock RUNMUTEXDIR empty";
   fi

   if [ -z "${MUTEXNAME}" ]; then
      fatal_error "mutex_unlock MUTEXNAME empty";
   fi

   LOCKDIR="${RUNMUTEXDIR}/${MUTEXNAME}";
   PIDFILE="${LOCKDIR}/pid";

   if [ -z "${LOCKDIR}" -o "${LOCKDIR}" == "/" ]; then
      fatal_error "mutex_unlock LOCKDIR empty or invalid";
   fi

   rm -rf "${LOCKDIR}";

   #sys_log "lock ${MUTEXNAME} released";
}

clear_vm_vars () {
   # -- Clears variables that vm.conf uses (ie; to avoid looping isses)
   VM_NAME=""
   VM_QUIRK=""
   VM_CPUS=""
   VM_MEMORY=""
   VM_ONBOOT=""
   VM_PRE_CMD=""
   VM_POST_CMD=""
   VM_BOOT_ZVOL=""
   VM_BOOT_PART="1"
   VM_BOOT_PART_TYPE=""
   VM_DISK_FILES=""
   VM_GRUB_DIR=""
   VM_CDROM=""
   VM_CDROM_MEDIA=""
   AUTO_NETWORKING=""
   VM_FRAMEBUFFER=""
   VM_FRAMEBUFFER_OPTS=""
   VM_USB3=""

   for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
      PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
      eval $PREFIX_BRIDGE='';
      
      PREFIX_TAP="VM_N${j}_TAP_NUM"
      eval $PREFIX_TAP=''
   done
}

vml_check () {
   # Check to make sure there are no sourcing errors and no duplicate TAP devices
   out=`find_all_configs`;
   USED_TAPS="";
   RET="0";

   for vm in $out; do
      if ! sh $vm; then
         echo "${VM_NAME}: Syntax error in '${vm}'!";
         RET="1";
      else
         # -- Clear vars
         clear_vm_vars;
         
         # -- Now load VM config
         . $vm;
         for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
            PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
            BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
            PREFIX_TAP="VM_N${j}_TAP_NUM"
            TAP=`eval echo "\$""$PREFIX_TAP"`
            
            if [ "$TAP" != "" ]; then
               #echo "$vm - $TAP";
               USE_CHECK=`echo "${USED_TAPS}" | tr " " "\n" | grep "^${TAP}:"`;
               if [ -n "${USE_CHECK}" ]; then
                  DUPE_TAP_HOST=`echo ${USE_CHECK} | awk -F : '{print $2}'`;
                  echo ">> ERROR: TAP ${TAP} used by ${VM_NAME} and ${DUPE_TAP_HOST}";
                  RET="1";
               else
                  USED_TAPS="${USED_TAPS} ${TAP}:${VM_NAME}";
               fi
            fi
         done
      fi
   done

   #echo "Used taps: ${USED_TAPS}";
   return ${RET};
}

vml_check_cond_show () {
   if ! vml_check > /dev/null 2> /dev/null; then
      echo "";
      echo ">> ERROR: Configuration errors found:";
      vml_check;
      echo "";
   fi
}

NiceSize ()
{
   SIZE="$1";     # Value (in bytes)
   SCALE="$2";    # Decimal places (default is 1)
   UNIT="$3";     # Unit (default is auto-detect)

   # ---- Set default decimal places
   #
   if [ -z "${SCALE}" ]; then
      SCALE=1;
   fi

   # ---- Set default unit
   #
   if [ -z "${UNIT}" ]; then
      if [ "${SIZE}" -gt 1125899906842624 ]; then
         UNIT="PiB";
      elif [ "${SIZE}" -gt 1099511627776 ]; then
         UNIT="TiB";
      elif [ "${SIZE}" -gt 1073740800 ]; then
         UNIT="GiB";
      elif [ "${SIZE}" -gt 1048576 ]; then
         UNIT="MiB";
      elif [ "${SIZE}" -gt 1024 ]; then
         UNIT="KiB";
      else
         UNIT="byte";
      fi
   fi

   # ---- Convert to unit
   #
   if [ "${UNIT}" == "PiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1125899906842624" | bc`;
   elif [ "${UNIT}" == "TiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1099511627776" | bc`;
   elif [ "${UNIT}" == "GiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1073741824" | bc`;
   elif [ "${UNIT}" == "MiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1048576" | bc`;
   elif [ "${UNIT}" == "KiB" ]; then
      NICE_SIZE=`echo "scale=${SCALE}; ${SIZE}/1024" | bc`;
   elif [ "${UNIT}" == "byte" ]; then
      NICE_SIZE="${SIZE}";
   else
      NICE_SIZE="NiceSize: unknown unit \"${UNIT}\"";
   fi

   NICE_SIZE=`echo ${NICE_SIZE} | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev`;
   echo "${NICE_SIZE} ${UNIT}";
}

vml_get_tap_to_vm_map () {
   out=`find_all_configs`;
   # -- Loop through each VM, returning a sorted list of tapN:vmnames values
   RET=""
   for vm in $out; do
      clear_vm_vars;
      
      . $vm;
      
      # -- Include state if there is one
      CUR_VM_STATE_FILE="${VM_STATE_DIR}/${VM_NAME}.state";
      if [ -e "${CUR_VM_STATE_FILE}" ]; then
         . ${CUR_VM_STATE_FILE};
      fi
      
      for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
         PREFIX_TAP="VM_N${j}_TAP_NUM"
         TAP=`eval echo "\$""$PREFIX_TAP"`
         
         if [ -n "$TAP" ]; then
            USE_CHECK=`echo ${members} | tr " " "\n" | grep "tap${TAP}"`;
            if [ -n "${USE_CHECK}" ]; then
               RET="${RET} tap${TAP}:${VM_NAME}"
            fi
         fi
      done
   done
   
   echo "${RET}" | tr " " "\n" | sort -u
}

vml_get_tap_vm () {
   TAP_TO_FIND="$1";
   TAP_MAP="$2";
   
   if [ -z ${TAP_MAP} ]; then
      TAP_MAP=`vml_get_tap_to_vm_map`;
   fi
   
   RET=`echo "${TAP_MAP}" | tr " " "\n" | grep "^${TAP_TO_FIND}:" | awk -F : '{print $2}'`;
   
   echo "${RET}";
}

vml_get_tap_to_bridge_map() {
   # -- Loop through each bridge and then VM, returning a sorted list of dev:bridgeN values
   out=`find_all_configs`;
   bridges=`find_all_bridges`;
   
   RET="";
   
   # -- Loop through each bridge
   for bridge in $bridges; do
      members=`ifconfig $bridge | grep "member: " | awk '{print $2}' | sort -u`;
      
      if [ -n "${members}" ]; then
         # -- loop through taps
         for CUR_DEV in $members; do
            RET="${RET} ${CUR_DEV}:${bridge}"
         done
      fi
   done

   echo "${RET}";
}

vml_get_tap_bridge () {
   TAP_TO_FIND="$1";
   TAP_MAP="$2";
   
   if [ -z ${TAP_MAP} ]; then
      TAP_MAP=`vml_get_tap_to_bridge_map`;
   fi
   
   RET=`echo "${TAP_MAP}" | tr " " "\n" | grep "^${TAP_TO_FIND}:" | awk -F : '{print $2}'`;
   
   echo "${RET}";
}
   
vml_get_bridge_name () {
   bridge="$1";
   BRIDGE_NAME_VAR="BRIDGE_${bridge}_NAME";
   BRIDGE_NAME=`eval echo "\$""$BRIDGE_NAME_VAR"`;
   
   echo "${BRIDGE_NAME}"
}

get_auto_tap_bridge_to_off_vm_map () {
   out=`find_all_configs`;
   # -- Loop through each VM, returning a sorted list of bridgeN:vmnames
   #    values for auto-configured taps that are  not up since they
   #    won't show up otherwise
   #    
   #    ie;  bridge3:testvm
   #
   RET=""
   for vm in $out; do
      clear_vm_vars;
      
      . $vm;
      
      vml_stat

      if [ "$?" == "1" ]; then
         STATE="On"
      else
         STATE="Off"
      fi      

      # -- Only bother if auto networking is enabled
      if [ "$AUTO_NETWORKING" == "YES" -a "${STATE}" == "Off" ]; then
         # -- Include state if there is one
         CUR_VM_STATE_FILE="${VM_STATE_DIR}/${VM_NAME}.state";
         if [ -e "${CUR_VM_STATE_FILE}" ]; then
            . ${CUR_VM_STATE_FILE};
         fi
         
         for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
            PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
            BRIDGE=`eval echo "\$""$PREFIX_BRIDGE"`
            PREFIX_TAP="VM_N${j}_TAP_NUM"
            TAP=`eval echo "\$""$PREFIX_TAP"`
            
            if [ -n "${BRIDGE}" -a -z "${TAP}" ]; then
               RET="${RET} bridge${BRIDGE}:${VM_NAME}"
            fi
         done
      fi
   done
   
   echo "${RET}" | tr " " "\n" | sort -u   
   }

vml_netmap () {
   vml_check_cond_show;
   
   out=`find_all_configs`;
   bridges=`find_all_bridges`;
   
   echo "Bridge To VM NIC Mappings";
   echo "";

   TAP_MAP=`vml_get_tap_to_vm_map`;
   AUTO_TAP_MAP=`get_auto_tap_bridge_to_off_vm_map`;
   
   # -- Loop through each bridge
   for bridge in $bridges; do
      members=`ifconfig $bridge | grep "member: " | awk '{print $2}' | sort -u`;
      
      echo -n "${bridge}";
      
      BRIDGE_NAME=`vml_get_bridge_name ${bridge}`;
      if [ -n "${BRIDGE_NAME}" ]; then
         echo " - ${BRIDGE_NAME}";
      else
         echo "";
      fi
      
      echo "  |";
      
      # -- loop through taps that exist for VMs
      for CUR_DEV in $members; do
         CUR_VM_NAME=`vml_get_tap_vm "${CUR_DEV}" "${TAP_MAP}"`;
         
         # -- See if dmesg has dev info
         if [ -z "${CUR_VM_NAME}" ]; then
            CUR_VM_NAME=`grep "^${CUR_DEV}: " /var/run/dmesg.boot | awk -F '<' '{print $2}' | awk -F '>' '{print $1}' | grep -v "^$" | head -n 1`;
         fi
         
         CUR_TAP_VM_COUNT=`echo "${CUR_VM_NAME}" | wc -l`;
         if [ ${CUR_TAP_VM_COUNT} -gt 1 ]; then
            printf "\n";
         fi
         
         # -- Display
         if [ -n "${CUR_VM_NAME}" ]; then
            printf "  +-- %5s -> %s\n" "${CUR_DEV}" "${CUR_VM_NAME}";
         #else
         #   printf "  +-- %5s\n" "${CUR_DEV}";
         fi
         
         if [ ${CUR_TAP_VM_COUNT} -gt 1 ]; then
            printf "      WARNING: MULTIPLE VMs ON ${CUR_DEV}!\n\n";
         fi
         
         
      done
      
      # -- loop through any auto-taps that on VMs not turned on
      CUR_BRIDGE_AUTO_VMS=`echo "${AUTO_TAP_MAP}" | egrep "^${bridge}:"`;
      for CUR_PAIR in ${CUR_BRIDGE_AUTO_VMS}; do
         CUR_VM_NAME=`echo "${CUR_PAIR}" | awk -F : '{print $2}'`;
         printf "  +-- %5s -> %s\n" "(off)" "${CUR_VM_NAME}";
      done
      
      # -- loop through for devices with no VM
      #    same as first loop (above the 'off vm' loop) but will grab physical
      #    devices so they're at the bottom
      FIRST_DEV="";
      for CUR_DEV in $members; do
         CUR_VM_NAME=`vml_get_tap_vm "${CUR_DEV}" "${TAP_MAP}"`;
         
         # -- See if dmesg has dev info
         if [ -z "${CUR_VM_NAME}" ]; then
            CUR_VM_NAME=`grep "^${CUR_DEV}: " /var/run/dmesg.boot | awk -F '<' '{print $2}' | awk -F '>' '{print $1}' | grep -v "^$" | head -n 1`;
         fi
         
         # -- Display
         if [ -z "${CUR_VM_NAME}" ]; then
            if [ -z "${FIRST_DEV}" ]; then
               printf "  |\n";
               FIRST_DEV="No";
            fi
            printf "  +-- %5s\n" "${CUR_DEV}";
         fi
         
      done
      
      echo "";
   done

   #echo "Used taps: ${USED_TAPS}";
   return ${RET};
}

get_zpath () {
   ZPATH=`zfs list -o name,mountpoint | sed -e s:"//":"/":g | grep $SCRIPTPATH | cut -d " " -f1 | head -n 1`;
   if [ -z "${ZPATH}" ]; then
      fatal_error "Couldn't get ZPATH";
   else
      echo "${ZPATH}";
   fi
}

vml_info () {
   VM_CONF=`get_config_file_name "${VM_NAME}"`;
   
   if [ -z "${VM_CONF}" ]; then
      fatal_error "Couldn't find VM config file";
   fi
   
   . ${VM_CONF};

   # -- Include state if there is one
   CUR_VM_STATE_FILE="${VM_STATE_DIR}/${VM_NAME}.state";
   if [ -e "${CUR_VM_STATE_FILE}" ]; then
      . ${CUR_VM_STATE_FILE};
   fi
   
   NICE_VM_MEMORY=`NiceSize $(( ${VM_MEMORY} * 1024 * 1024 ))`;
   NICE_OS=`vml_quirk_to_text ${VM_QUIRK}`;
   
   echo "VM Name:       ${VM_NAME}";
   echo "OS:            ${NICE_OS}";
   echo "CPU Cores:     ${VM_CPUS}";
   echo "RAM:           ${NICE_VM_MEMORY}";
   echo "Auto-start:    ${VM_ONBOOT}";
   echo "";
   
   if [ -n "${VM_BOOT_ZVOL}" ]; then
      ZPATH=`get_zpath`
      VM_ZPOOL="${ZPATH}/${VM_BOOT_ZVOL}";
      SIZE=`zfs get -Hp volsize ${VM_ZPOOL} | awk '{print $3}'`
      USED=`zfs get -Hp logicalused ${VM_ZPOOL} | awk '{print $3}'`
      NICE_SIZE=`NiceSize ${SIZE}`;
      NICE_USED=`NiceSize ${USED}`;
      
      printf "%-14s %9s  %s\n" "Disk (ZVOL):" "${NICE_SIZE}" "${VM_ZPOOL} (${NICE_USED} on disk)";
      
      VM_SNAPSHOTS=`zfs list -t snap | egrep "^${VM_ZPOOL}@" | awk '{print $1 ":" $2}'`;
      for VM_SNAPSHOT in ${VM_SNAPSHOTS}; do
         CUR_SNAP_NAME=`echo "${VM_SNAPSHOT}" | awk -F : '{print $1}'`;
         CUR_SNAP_SIZE=`echo "${VM_SNAPSHOT}" | awk -F : '{print $2}'`;
         printf "                          %9s  %s\n" "${CUR_SNAP_NAME} (${CUR_SNAP_SIZE} used by snapshot)";
      done
   fi
   
   if [ -n "${VM_DISK_FILES}" ]; then
      for CUR_DISK_FILE_RAW in ${VM_DISK_FILES}; do
         # -- Expand relative if needed
         if echo "${CUR_DISK_FILE_RAW}" | grep "^/" > /dev/null; then
            CUR_DISK_FILE="${CUR_DISK_FILE_RAW}"
         else
            CUR_DISK_FILE="${SCRIPTPATH}/${CUR_DISK_FILE_RAW}";
         fi
         if [ -e "${CUR_DISK_FILE}" ]; then
            SIZE=`stat -f %z "${CUR_DISK_FILE}"`;
            NICE_SIZE=`NiceSize ${SIZE}`;
         else
            NICE_SIZE="--";
         fi
         
         printf "%-14s %9s  %s\n" "Disk (File):" "${NICE_SIZE}" "${CUR_DISK_FILE}";
      done
   fi
   
   echo "";
   for j in 1 2 3 4 5 6 7 8 9 10 11 12; do
      NIC_NO="$j";
      PREFIX_BRIDGE="VM_N${j}_BRIDGE_NUM"
      CUR_BRIDGE_NO=`eval echo "\$""$PREFIX_BRIDGE"`
      CUR_BRIDGE="bridge${CUR_BRIDGE_NO}";
      PREFIX_TAP="VM_N${NIC_NO}_TAP_NUM"
      TAP_NO=`eval echo "\$""$PREFIX_TAP"`
      
      if [ -z "${TAP_NO}" ]; then
         if [ "${AUTO_NETWORKING}" == "YES" ]; then
            TAP_DEV="auto";
         fi
      else
         TAP_DEV="tap${TAP_NO}";
      fi
      
      if [ -n "${CUR_BRIDGE_NO}" ]; then
         #echo "x";
         #REAL_BRIDGE=`vml_get_tap_bridge "${TAP_DEV}"`;

         CUR_BRIDGE_NAME=`vml_get_bridge_name ${CUR_BRIDGE}`;
         if [ -z "${CUR_BRIDGE_NAME}" ]; then
            printf "NIC %-2s -> %-6s -> %s\n" "${NIC_NO}" "${TAP_DEV}" "${CUR_BRIDGE}";
         else
            printf "NIC %-2s -> %-6s -> %s (%s)\n" "${NIC_NO}" "${TAP_DEV}" "${CUR_BRIDGE_NAME}" "${CUR_BRIDGE}";
            #echo "NIC ${NIC_NO}: (${TAP_DEV}) -> ${CUR_BRIDGE_NAME} (${CUR_BRIDGE})";
         fi
      fi
   done
}

vml_list () {
   vml_check_cond_show

   # -- Make sure we're root, and if not warn since 'on' etc won't display right
   if [ `id -u`x != "0"x ]; then
      echo "" >&2;
      echo "WARNING: Running as non-root, VM state and other info will not be reported correctly!" >&2;
      echo "" >&2;
      IS_ROOT="No";
   else
      IS_ROOT="Yes";
   fi
   
   out=`find_all_configs`;
   COL_FORMAT="%-20s %-13s %-7s %-6s %4s %7s %7s %11s\n";
   
   printf "${COL_FORMAT}" "Guest Name" "OS" "State" "Boot" "CPUs" "RAM" "Use" "Res";
   printf -- "---------------------------------------------------------------------------------- -\n";

   TOTAL_USED_CPU="0";
   TOTAL_USED_MEM="0";
   TOTAL_VM_MEMORY="0";
   
   for vm in $out; do
      . $vm
      TYPE=$( vml_quirk_to_text )
      vml_stat
      if [ "$?" == "1" ]; then
         STATE="On"
      else
         STATE="Off"
      fi
      
      if [ "${IS_ROOT}" == "Yes" ]; then
         if [ "${STATE}" == "On" ]; then
            USED_CPU=`ps aux -ww | grep "bhyve: $VM_NAME (bhyve)" | grep -v grep | awk '{print $3}' | awk -F . '{print $1}'`;
            if [ `id -u` -eq "0" ]; then
               USED_MEM_RAW=`bhyvectl --get-stats --vm=$VM_NAME | grep "^Resident memory" | awk '{print $3}'`;
               if [ -z "${USED_MEM_RAW}" ]; then
                  USED_MEM_RAW="0";
               fi
               USED_MEM=`NiceSize ${USED_MEM_RAW} 1`;
               TOTAL_USED_MEM="$(( ${TOTAL_USED_MEM} + ${USED_MEM_RAW} ))";
            else
               USED_MEM="--";
            fi
         else
            USED_CPU="0";
            USED_MEM="--";
         fi
         
         # -- Convert MiB into bytes
         VM_MEMORY=$(( ${VM_MEMORY} * 1024 * 1024 ));
         
         if [ -n "${VM_MEMORY}" ]; then
            TOTAL_VM_MEMORY="$(( ${TOTAL_VM_MEMORY} + ${VM_MEMORY} ))";
         else
            NICE_TOTAL_VM_MEMORY="n/a";
         fi
         
         if [ -n "${USED_CPU}" ]; then
            TOTAL_USED_CPU="$(( ${TOTAL_USED_CPU} + ${USED_CPU}))";
         fi
         
         VM_MEMORY=`NiceSize ${VM_MEMORY} 0`;
      else
         STATE="?";
         USED_CPU="?";
         USED_MEM="?";
         VM_MEMORY="?";
         TOTAL_VM_MEMORY="?";
         NICE_TOTAL_VM_MEMORY="?";
      fi

      if [ "${VM_ONBOOT}" == "YES" ]; then
         NICE_VM_ONBOOT="Auto";
      else
         NICE_VM_ONBOOT="Manual";
      fi
      
      printf "${COL_FORMAT}" "$VM_NAME" "$TYPE" "$STATE" "${NICE_VM_ONBOOT}" "$VM_CPUS" "$VM_MEMORY" "${USED_CPU}%" "$USED_MEM";
      
      # -- Check for mismatched
      if ! echo "${vm}" | egrep "/${VM_NAME}/vm.conf$" > /dev/null; then
         echo "  ^ --- WARNING: VM name defined in vm.conf mismatches mount-point!" >&2;
         echo "" >&2;
      fi
   done 

   if [ "${IS_ROOT}" == "Yes" ]; then
      NICE_TOTAL_VM_MEMORY=`NiceSize ${TOTAL_VM_MEMORY} 0`; 
      NICE_TOTAL_USED_MEM=`NiceSize ${TOTAL_USED_MEM}`;
   else
      TOTAL_USED_CPU="??";
      NICE_TOTAL_VM_MEMORY="??";
      NICE_TOTAL_USED_MEM="??";
   fi

   printf -- "---------------------------------------------------------------------------------- -\n";
   printf "${COL_FORMAT}" "" "" "" "" "" "${NICE_TOTAL_VM_MEMORY}" "${TOTAL_USED_CPU}%" "${NICE_TOTAL_USED_MEM}";
}

quick_padding () {
   LENGTH=`echo ${1} | wc -c | tr -d "\n"`
   PAD_CHAR=`expr ${2} - ${LENGTH}`
   for a in `seq 1 $PAD_CHAR`; do
      printf " "
   done
}

vml_rcstart () {

   sys_log "starting auto-boot VMs ...";
   echo "bhyve management tool"

   # Kernel modules
   if [ "${bmt_kern_modules}" == "" ]; then
      bmt_kern_modules="vmm if_tap if_bridge"
      printf " * loading default kernel modules:\n"
   else
      printf " * loading user kernel modules: \n"
   fi


   for MOD in ${bmt_kern_modules}; do
      printf "     * ${MOD}"
      kldload $MOD > /dev/null 2>&1
      printf "$( quick_padding $MOD 20 )"
      echo "done"
   done

   # Sysctls
   if [ "${bmt_sysctls}" == "" ]; then
      bmt_sysctls="net.link.tap.up_on_open=1"
      printf " * loading default sysctls:\n"
   else
      printf " * loading user sysctls: \n"
   fi


   for MOD in ${bmt_sysctls}; do
      echo "     * ${MOD}"
      sysctl $MOD > /dev/null 2>&1
   done
      

#  sysctl net.link.tap.up_on_open=1

   # Virtual Machines
   out=`find_all_configs`;
   printf " * starting vms: \n"
   for vm in $out; do
      . $vm 

      if [ "$VM_ONBOOT" == "YES" ]; then
         printf "     * ${VM_NAME}"
         $SCRIPT start $VM_NAME
         printf "$( quick_padding $VM_NAME 20 )"
         echo "done"
         if [ -n "${RC_START_VM_DELAY}" ]; then
            sleep ${RC_START_VM_DELAY};
         fi
      fi
   done
   echo "bmt init finished"   
   sys_log "auto-boot VMs started";
}

vml_wait_for_poweroff(){
   while true; do
      vml_stat
      if [ "$?" == "0" ]; then   
         break 
      fi 
   done
}

vml_rcstop() {
   sys_log "shutting down vms ...";
   printf "bmt stopping all running vms: \n"
   out=`find_all_configs`;

   # Quick stop loop
      for vm in $out; do
         . $vm
      vml_stop -q 
   done

   # Wait for things to actually stop
   for vm in $out; do
      . $vm
      printf "     * ${VM_NAME}"
      while true; do
         vml_stat
         if [ "$?" == "0" ]; then   
            break 
         fi 
      done
      printf "$( quick_padding $VM_NAME 20 )"
      echo "done"
   done

   # Kernel modules
   if [ "${bmt_kern_modules}" == "" ]; then
      bmt_kern_modules="vmm if_tap if_bridge"
      printf " * unloading default kernel modules:\n"
   else
      printf " * unloading user kernel modules: \n"
   fi


   for MOD in ${bmt_kern_modules}; do
      printf "     * ${MOD}"
      kldunload $MOD > /dev/null 2>&1
      printf "$( quick_padding $MOD 20 )"
      echo "done"
   done


   sys_log "vm shutdown complete";
   printf "bmt shutdown finished\n"
}

vml_stop () {
   sys_log "${VM_NAME}: stopping";
   if [ "$ARG_FORCE" == "-f" ]; then
      bhyvectl --vm=$VM_NAME --force-poweroff
      bhyvectl --vm=$VM_NAME --destroy
   else
      vml_stat
      if [ "$?" == "1" ]; then
         tpid=`ps aux -ww | grep "bhyve: $VM_NAME (bhyve)" | grep -v grep | awk '{print $2}'`
         kill -TERM $tpid
      else
         if [ "$1" != "-q" ]; then
            echo "VM is not running"
         fi
      fi
   fi
}

vml_destroy () {
   sys_log "${VM_NAME}: destroying";
   ARG_FORCE="YES"
   vml_stop  
   zfs destroy -r $ZPATH
   echo "$VM_NAME destroyed"
}

vml_edit () {
   $EDITOR $VM_ROOT"/vm.conf"
}

vml_vm_exists () {
   if [ -f "${VM_LIVES}/${VM_NAME}/vm.conf" ]; then
      return 1
   else
      return 0
   fi 
}

vml_clone () {
   # If the VM is running, error and exit
   if [ "$FORCE" == "YES" ]; then
      vml_stop
      echo "Waiting for vm to poweroff..."
      vml_wait_for_poweroff
      echo "VM Powered off"
   else
      vml_stat
   
      if [ "$?" == "1" ]; then
         echo "VM is running. Use -f flag to shutdown before cloning"
         exit
      fi
   fi 

   # Actually do the clone
   SNAPSHOT_NAME="`date +'%s'`_clone_${ARG_BONUS}"

   zfs snapshot -r ${ZPATH}@${SNAPSHOT_NAME}
   zfs clone ${ZPATH}@${SNAPSHOT_NAME} ${BASE_ZPATH}/$ARG_BONUS
   # Clone all of the zvols into their destination
   for ds in `zfs list -r -H -t volume -o name $ZPATH`
   do
      DS_NAME=${ds##*/}
      zfs clone ${ds}@${SNAPSHOT_NAME} ${BASE_ZPATH}/${ARG_BONUS}/${DS_NAME}
   done

   # Rename the VM in the configuration file
   sed -i -- "s/VM_NAME=\"${VM_NAME}\"/VM_NAME=\"${ARG_BONUS}\"/g" ${VM_LIVES}/${ARG_BONUS}/vm.conf
   rm ${VM_LIVES}/${ARG_BONUS}/vm.conf--  
}

vml_copy () {
   NEW_VM="${ARG_BONUS}";
   
   if [ -z "${NEW_VM}" ]; then
      fatal_error "Missing new VM name (sanity check)";
   fi
   
   echo -n "Copying '${VM_NAME}' to '${NEW_VM}' ... "
   vml_send | bmt receive ${NEW_VM};
   
   echo "Done";
   
   if [ "${ARG_BONUS2}" == "-d" ]; then
      echo -n "Removing snapshots on '${NEW_VM}' ... ";
      SNAPSHOTS=`zfs list -t snap | egrep "^${BASE_ZPATH}/${NEW_VM}[/|@]" | awk '{print $1}'`;
      
      for SNAP in ${SNAPSHOTS}; do
         zfs destroy ${SNAP};
      done
      echo "Done";
   fi
}

vml_rename () {
   vml_stat

   if [ "$?" == "1" ]; then
      echo "The VM cannot be renamed while running"
      exit
   fi

   VM_NAME_TEMP="${VM_NAME}"
   VM_NAME="${ARG_BONUS}"
   vml_require_no_exist
   VM_NAME="${VM_NAME_TEMP}"

   zfs rename ${ZPATH} ${BASE_ZPATH}/${ARG_BONUS}
   sed -i -- "s/VM_NAME=\"${VM_NAME}\"/VM_NAME=\"${ARG_BONUS}\"/g" ${VM_LIVES}/${ARG_BONUS}/vm.conf
   rm ${VM_LIVES}/${ARG_BONUS}/vm.conf--  
}

zvol_clone_check () {
   # -- Make sure this VM has no zvols that are clones (and thus won't copy)
   VM_ZVOL_BASE="$1";
   
   if [ -z "${VM_ZVOL_BASE}" ]; then
      return 1;
   fi
   
   VM_ZVOL_LIST=`zfs list -o name | egrep "^${VM_ZVOL_BASE}(/|$)"`;
   for CUR_ZVOL in ${VM_ZVOL_LIST}; do
       CUR_ORIGIN=`zfs get -H -o value origin ${CUR_ZVOL}`;
       if [ "${CUR_ORIGIN}" != "-" ]; then
          return 1
       fi
   done
   return 0
}

vml_send () {
   # -- Make sure this VM has no zvols that are clones (and thus won't copy)
   if ! zvol_clone_check "${ZPATH}"; then
      fatal_error "${CUR_ZVOL} is a clone of another zvol or is the source of another clone.   Sending it somewhere isn't going to work because its reference will be missing.  Use 'zfs promote ${CUR_ZVOL}' to detach it from it's base and send again.  You may need to run that command multiple times if it's a nested clone.";
   fi

   if [ "$FORCE" == "YES" ]; then
      vml_stop
      echo "Waiting for vm to poweroff..."
      vml_wait_for_poweroff
      echo "VM Powered off"
   else
      vml_stat
   
      if [ "$?" == "1" ]; then
         echo "VM is running. Use -f flag to shutdown before migration"
         exit
      fi
   fi 

   # Actually do the export
   SNAPSHOT_NAME="`date +'%s'`_send"

   zfs snapshot -r ${ZPATH}@${SNAPSHOT_NAME}
   zfs send -R ${ZPATH}@${SNAPSHOT_NAME}
#  zfs send -vR ${ZPATH}@${SNAPSHOT_NAME}
}

vml_require_no_exist () {
   vml_vm_exists
   if [ "$?" == "1" ]; then
      echo "VM ${VM_NAME} already exists."
      exit
   fi
}

vml_require_exist () {
   vml_vm_exists
   if [ "$?" == "0" ]; then
      echo "VM ${VM_NAME} doesn't exist"
      exit
   fi

}

vml_require_off () {
   vml_stat
   if [ "$?" == "1" ]; then
      echo "VM ${VM_NAME} cannot be running"
      exit
   fi
}

vml_receive () {
   # Special hook for 'bmt scp' pre-send test
   if [ "${VM_NAME}"x == "_scp_test_nop_ivpk5t_"x ]; then
      #echo "Remote command test success.";
      exit 0;
   fi

   vml_require_no_exist
   zfs receive ${BASE_ZPATH}/${VM_NAME}
   OLD_VM_NAME=`cat ${VM_LIVES}/${VM_NAME}/vm.conf | grep VM_NAME`
   sysrc -f ${VM_LIVES}/${VM_NAME}/vm.conf VM_NAME="${VM_NAME}" > /dev/null;
   
}

vml_help () {
   vml_usage
}

vml_usage (){
   echo "
USAGE:
bmt attach <vm_name>
bmt check
bmt create <vm name> [ -V VOLSIZE[K,M,G,T etc ]
bmt copy <vm name> <new vm name> [ -d ]
bmt clone <vm name> <new vm name>
bmt destroy <vm_name>
bmt edit <vm_name>
bmt exec <vm_name> '<command>' 
bmt info <vm_name>
bmt list 
bmt rcstart
bmt rcstop
bmt get <vm name> <CONFIG_VAR>
bmt set <vm name> <CONFIG_VAR>=<new value>
bmt netmap
bmt receive [new_vm_name]
bmt rename <current vm name> <new vm name>
bmt send <vm_name>
bmt start <vm_name> [ -d ]
bmt status <vm_name>
bmt stop <vm_name> [ -f ]
bmt scp <vm_name> <remote-server:vm_name>"
}

# Send a command to the console of a VM #
vml_exec () {
   screen -S bhyve.${VM_NAME} -X log 
   screen -S bhyve.${VM_NAME} -X stuff "${ARG_BONUS}"
   screen -S bhyve.${VM_NAME} -p0 -X eval "stuff \015"
   screen -S bhyve.${VM_NAME} -X log 
   LINES=`cat screenlog.0 | wc -l | tr -d ' '`
   HEAD_LINES=`echo "${LINES} - 1" | bc`
   if [ "${HEAD_LINES}" -eq 0 ]; then
      exit 0
   else
      printf ''
      cat screenlog.0 | tail -n ${LINES} | head -n ${HEAD_LINES} 
      rm screenlog.0
   fi
}

vml_get () {
   echo $ARG_BONUS | grep -q \=
   IS_SET=$?

   if [ "${IS_SET}" == "0" ]; then
       echo "Use set instead of get"
       exit
   fi
   sysrc -nf "${VM_LIVES}/${VM_NAME}/vm.conf" ${ARG_BONUS}
}

vml_set () {
   sysrc -f "${VM_LIVES}/${VM_NAME}/vm.conf" ${ARG_BONUS}
}

vml_create () {
   # Syntax
   # bmt create [ vm ] [ bonus ( volume size) 
   ZVOL_SIZE="10G";

   if [ "${ARG_BONUS}"x == "-V"x ]; then
      if [ -n "${ARG_BONUS2}" ]; then
         ZVOL_SIZE="${ARG_BONUS2}";
      else
         fatal_error "Missing flag param: 'create -V <volsize>'";
      fi
   fi
   
   if ! zfs create "${BASE_ZPATH}/$VM_NAME"; then
      fatal_error "Couldn't create zvol '$BASE_ZPATH/$VM_NAME'";
   fi
   if ! zfs create -V "$ZVOL_SIZE" -o refreservation=none "$BASE_ZPATH/$VM_NAME/disk"; then
      fatal_error "Couldn't create zvol '$BASE_ZPATH/$VM_NAME/disk'";
   fi
   
   echo "#!/bin/sh

# -- VM Basics
#
VM_NAME=\"$VM_NAME\""'
VM_QUIRK="0"         # - See OS Type list below
VM_CPUS="1"          # - Number of virtual CPUs
VM_MEMORY="1024"     # - Guest RAM allocation
VM_ONBOOT="YES"      # - Start this VM when the host boots
VM_PRE_CMD=""        # - Command to run before starting
VM_POST_CMD=""       # - Command to run after exiting

# -- Booting / Disks
#
VM_BOOT_ZVOL="disk"  # - The zvol sub-name to boot from
VM_BOOT_PART_TYPE="" # - The partition scheme: msdos (default) or gpt
VM_BOOT_PART="1"     # - The partition to boot from
VM_DISK_FILES=""     # - Disk-file alternative to BOOT_ZVOLs
VM_GRUB_DIR=""       # - Override the grub dir (ie; /grub2 for LVM)
                     #   (normally dictated by VM_QUIRK logic)

# -- CD/DVD Media
#
VM_CDROM="0"
VM_CDROM_MEDIA=""

# -- File-based Disk(s)
#

# -- Networking
#  ( Up to 12 NIC are possible following the same naming convention )
#
AUTO_NETWORKING="YES"
VM_N1_BRIDGE_NUM=""
VM_N1_TAP_NUM=""

VM_N2_BRIDGE_NUM=""
VM_N2_TAP_NUM=""

# -- Framebuffer
#
VM_FRAMEBUFFER="0"
VM_FRAMEBUFFER_OPTS="tcp=0.0.0.0:5900,wait"

# -- USB 3.0
#
VM_USB3="0"

# -- PCI Passthru (see README.md for usage) 
#
VM_PCI_PT=""

# -- OS Type 
#  0 FreeBSD
#  1 CentOS 6.x
#  2 CentOS 7.x
#  3 Ubuntu / Debian
#  4 Fedora 23
#  5 Arch
#  6 NetBSD
#  7 OpenBSD 5.8
#  8 Windows 10
#' > "$VM_LIVES/$VM_NAME/vm.conf"
   echo "VM '${VM_NAME}' created";
}

vml_setup () {
   mkdir -p ${VM_LIVES} && 
   zfs create -o compression=lz4 -o mountpoint=${VM_LIVES} ${BASE_ZPATH}
}

vml_quirk_to_text () {

   case $VM_QUIRK in
      0) VM="FreeBSD";;
      1) VM="CentOS 6";;
      2) VM="CentOS 7";;
      3) VM="Ubuntu";;
      5) VM="Arch";;
      6) VM="NetBSD";;
      7) VM="OpenBSD";;
      8) VM="Windows 10";;
      *) VM="UNKNOWN";;
   esac
   echo "${VM}"

}

vml_sanity () {
   # These are the required binaries
   REQUIRED_BINARIES="screen"

   for bin in $REQUIRED_BINARIES; do
      if [ ! -f "`whereis -qb ${bin}`" ]; then
         echo "${bin} not installed, and it is required"
         FATAL="YES"
      fi
   done

   # These are the optional binaries
   OPTIONAL_BINARIES="grub-bhyve fusefs-ext2"

   for bin in $OPTIONAL_BINARIES; do
      if [ ! -f "`whereis -qb ${bin}`" ]; then
         echo "${bin} not installed, but it is optional"
      fi
   done

   if [ "${FATAL}" == "YES" ]; then
      echo "There were fatal errors"
      exit
   fi

   # Is the ZPATH set up yet?
   BASE_ZPATH=`zfs get bvm: | grep -v inherited | grep yes | head -n 1 | cut -d " " -f 1`
   if [ "${BASE_ZPATH}" == "" ]; then
      echo "BMT does not appear to be set up yet. Please run bmt setup."
      exit
   fi
}

vml_scp () {
   # -- Make sure this VM has no zvols that are clones (and thus won't copy)
   if ! zvol_clone_check "${ZPATH}"; then
      fatal_error "${CUR_ZVOL} is a clone of another zvol or is the source of another clone.   Sending it somewhere isn't going to work because its reference will be missing.  Use 'zfs promote ${CUR_ZVOL}' to detach it from it's base and send again.  You may need to run that command multiple times if it's a nested clone.";
   fi
   
   if [ "$FORCE" == "YES" ]; then
      vml_stop
      echo "Waiting for vm to poweroff..."
      vml_wait_for_poweroff
      echo "VM Powered off"
   else
      vml_stat
   
      if [ "$?" == "1" ]; then
         echo "VM is running. Use -f flag to shutdown before migration"
         exit
      fi
   fi 
   
   # Work out remote server and VM name
   REMOTE_SERVER=`echo "${ARG_BONUS}" | awk -F : '{print $1}'`;
   REMOTE_VM_NAME=`echo "${ARG_BONUS}" | awk -F : '{print $2}'`;
   
   if [ -z "${REMOTE_SERVER}" ]; then
      fatal_error "missing remote server (check arg format)"
   fi
   
   if [ -z "${REMOTE_VM_NAME}" ]; then
      fatal_error "missing remote vm name (check arg format)"
   fi
   
   # Actually do the export
   SNAPSHOT_NAME="`date +'%s'`_scp"
   
   # Work out the remote user to use
   REMOTE_USER="${SUDO_USER}";
   SUDO_COMMAND="sudo";
   if [ -z "${REMOTE_USER}" ]; then
      REMOTE_USER="${USER}";
      SUDO_COMMAND="";
   fi
   
   # Test sudo
   if ! ssh ${REMOTE_USER}@${REMOTE_SERVER} ${SUDO_COMMAND} -n /usr/local/ateam/sbin/bmt receive _scp_test_nop_ivpk5t_; then
      echo "";
      fatal_error "Testing sudo failed";
   fi
   
   echo -n "Sending local VM '${VM_NAME}' to server '${REMOTE_SERVER}' as remote VM '${REMOTE_VM_NAME}' ... ";
   zfs snapshot -r ${ZPATH}@${SNAPSHOT_NAME}
   zfs send -R ${ZPATH}@${SNAPSHOT_NAME} | ssh ${REMOTE_USER}@${REMOTE_SERVER} ${SUDO_COMMAND} -n /usr/local/ateam/sbin/bmt receive ${REMOTE_VM_NAME};
   zfs destroy ${ZPATH}@${SNAPSHOT_NAME}
   echo "Done!";
}



############################################## MAIN

# check setup
#vml_sanity



# Argument Handling
# bmt [ action ] [ vm ] [ bonus ] 
# bmt create [ vm ] 

# Flags
for arg in $*
do
   case $arg in


      f)
         ARG_FORCE="YES"
      ;;

      is)
         # This hack allows the start command to launch screens without looping
         IN_SCREEN="YES"
         echo "IN SCREEN DETECTED"
      ;;

      q) 
         ARG_QUIET="YES"
      ;;

      c)
         echo "Clear"
      ;;

      
   esac

done


# Where are we executing from?
SCRIPT=$(readlink -f "$0")

# Argument $1, action
   
   # Check if the first argument is set
   ARG_ACTION="$1"
   if [ "$ARG_ACTION" == "" ]; then
      echo "Argument action not provided"
      vml_usage
      exit
   fi

   # Make sure a valid action is provided
   case $ARG_ACTION in
      help)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;
      
      attach)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      scp)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;
      clone)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
      copy)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
      
      create)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         if [ "$2" == "" ]; then
            echo "No vm name provided to create"
            exit
         else
            VM_NAME=$2
         fi
         ROOT_REQUIRED="YES"
      ;;

      destroy)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;


      edit)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      exec)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      get)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      check)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;
      
      netmap)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      info)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;

      list)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      rcstart)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="YES"
      ;;

      rcstop)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="YES"
      ;;

      receive)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         VM_NAME="${2}"
         ROOT_REQUIRED="NO"
      ;;
   
      rename)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      sanity)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         ROOT_REQUIRED="NO"
      ;;

      send)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
      
      set)
         BONUS_REQUIRED="YES"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;
   
      setup)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         SETUP_POOL="zroot"
         ROOT_REQUIRED="YES"
      ;;
   
      start)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
      ;;

      status)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;

      stop)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="YES"
         if [ "$3"=="-f" ]; then
            ARG_FORCE="-f"
         fi
      ;;

      vm_exists)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="NO"
         VM_NAME="${2}"
         ROOT_REQUIRED="NO"
      ;;

      wait_for_poweroff)
         BONUS_REQUIRED="NO"
         VM_REQUIRED="YES"
         ROOT_REQUIRED="NO"
      ;;
   
      *)
         echo "$ARG_ACTION is an invalid action"
         vml_usage
         exit 1;
      ;;
   esac  

# Are we root?
if [ "${ROOT_REQUIRED}" == "YES" ]; then
   if [ "`whoami | tr -d \"\\n\"`" != "root" ]; then
      echo "The $ARG_ACTION action requires root"
      exit 1;
   fi
fi
      
# Deal with the VM_NAME, if necessary
if [ "$VM_REQUIRED" == "YES" ] ; then
   VM_NAME=$2

   if [ "$VM_NAME" == "" ]; then
      echo "No vm name provided"
      exit 1;
   fi

   vml_require_exist

   # Source the configuration
   VM_ROOT="${VM_LIVES}/${VM_NAME}"

   if ! [ -d "${VM_ROOT}" ]; then
      fatal_error "Invalid VM_ROOT \"${VM_ROOT}\"";
   fi

   if ! [ -r "${VM_ROOT}/vm.conf" ]; then
      fatal_error "vm.conf missing from ${VM_ROOT}";
   fi

   . "${VM_ROOT}/vm.conf"

   SCRIPTPATH="$VM_ROOT"
   ZPATH=`get_zpath`

   if [ -z "${ZPATH}" ]; then
      echo " >>> ERROR: Could not establish ZPATH for $VM_ROOT";
      exit 1;
   fi

fi

# Deal with bonus $3
if [ -n "$3" ]; then
   ARG_BONUS="$3"
fi
if [ -n "$4" ]; then
   ARG_BONUS2="$4"
fi

if [ "$BONUS_REQUIRED" == "YES" -a -z "${ARG_BONUS}" ]; then
   echo "Not enough arguments"
   exit 1;
fi

# Early escape if we are listing
#if [ "$1" == "list" ] || [ "$1" == "rcstart" ] || [ "$1" == "rcstop" ]; then
#  vml_$1 $@
#  exit
#fi

# Early escape if we are creating
#if [ "$2" == "create" ] ; then
#  vml_$2 $@
#  exit
#fi


vml_$ARG_ACTION
RET_VAL=$?

exit ${RET_VAL}
